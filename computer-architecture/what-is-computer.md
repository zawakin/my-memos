#  Computer

[Computer(en.wikipedia)](https://en.wikipedia.org/wiki/Computer)

コンピュータとは、コンピュータのプログラミングによって、一連の算術演算や論理演算を自動的に実行するように指示することができる機械のことです。現代のコンピュータは、プログラムと呼ばれる一般化された一連の操作に従う能力を持っています。これらのプログラムによって、コンピュータは非常に広範囲のタスクを実行することができます。「完全な」動作に必要なハードウェア、オペレーティングシステム（メインソフトウェア）、および周辺機器を含む「完全な」コンピュータをコンピュータシステムと呼ぶことができます。この用語は、接続されて一緒に動作するコンピュータのグループ、特にコンピュータネットワークまたはコンピュータクラスタに対しても同様に使用することができる。

コンピュータは、多種多様な産業用および民生用機器の制御システムとして使用されています。これには、電子レンジやリモコンのような単純な特殊目的装置、産業用ロボットやコンピュータ支援設計のような工場用装置、さらには、パーソナルコンピュータやスマートフォンのようなモバイル装置のような汎用装置も含まれる。インターネットはコンピュータ上で実行されており、何億ものコンピュータとそのユーザーを接続しています。

初期のコンピュータは計算機としてしか考えられていませんでした。古代から、そろばんのような簡単な手動の装置は、人々が計算をするのに役立っていました。産業革命の初期には、織機のパターンを案内するなど、長時間の退屈な作業を自動化するための機械装置がいくつか作られました。20 世紀初頭には、より洗練された電気機械が特殊なアナログ計算を行いました。最初のデジタル電子計算機は、第二次世界大戦中に開発されました。1940年代後半に最初の半導体トランジスタが登場し、1950年代後半にはシリコンベースのMOSFET（MOSトランジスタ）とモノリシック集積回路（IC）チップ技術が登場し、1970年代にはマイクロプロセッサとマイクロコンピュータ革命につながりました。それ以来、コンピュータのスピード、パワー、汎用性は飛躍的に向上し、MOSトランジスタの数は（ムーアの法則で予測されるように）急速に増加し、20世紀後半から21世紀初頭のデジタル革命につながっています。

従来、現代のコンピュータは、少なくとも1つの処理要素、典型的には金属酸化物半導体(MOS)マイクロプロセッサの形をした中央処理装置(CPU)と、コンピュータメモリの一種、典型的にはMOS半導体メモリチップで構成されています。処理要素は、算術演算および論理演算を実行し、シーケンシングおよび制御ユニットは、記憶された情報に応答して演算の順序を変更することができる。周辺装置としては、入力装置（キーボード、マウス、ジョイスティックなど）、出力装置（モニタ画面、プリンタなど）、入出力装置の両方の機能を果たす装置（例えば、２０００年代のタッチスクリーン）などがある。周辺機器は、外部から情報を取り出すことを可能にし、操作の結果を保存して取り出すことを可能にするものである。



# 語源

オックスフォード英語辞典によると、「コンピュータ」という言葉が初めて使われたのは、1613年にイギリスの作家リチャード・ブレイスウェイトが書いた「The Yong Mans Gleanings」という本の中で、「I haue [sic] read the trueest computer of Times, and the best Arithmetician that euer [sic] breathed, and he reduceth thy dayes into a short number」と書かれています。この言葉のこの用法は、人間のコンピュータ、つまり計算や計算を行う人を指していました。この言葉は20世紀半ばまで同じ意味で使われていました。この時代の後半には、女性がコンピュータとして雇われることが多かったが、その理由は、女性の賃金が男性よりも低かったからである。

Online Etymology Dictionaryによると、"computer "の最初の使用は1640年代で、"one who calculates "を意味する "compute (v.)からのエージェント名詞 "となっています。Online Etymology Dictionaryによると、「（あらゆるタイプの）計算機」を意味するこの用語の使用は1897年のものであるとされています。Online Etymology Dictionaryによると、「プログラム可能なデジタル電子コンピュータ」を意味するこの用語の「現代的な使用」は、「1945年にこの名前で、1945年から; [in a]oretical [sense] from 1937年から、Turing machineとして」となっています。



# 歴史



## 20世紀以前

デバイスは何千年にもわたって計算を補助するために使用されてきましたが，ほとんどが指との一対一の対応を使用しています．最も初期の計数装置は、おそらくタリースティックの一形態でした。肥沃な三日月の至るところで、その後の記録保持の補助として、中空の素焼きの粘土容器に封入された、家畜や穀物などの品目の数を表す計算機（粘土の球体、円錐形など）が使われていました。



そろばんは当初、算数の仕事に使用されていました。ローマのそろばんは、早くも紀元前2400年にバビロニアで使用されていた装置から開発されました。それ以来、他の多くの形式の計算台やテーブルが発明されてきました。中世のヨーロッパの勘定奉行所では、金額を計算するための補助として、テーブルの上に市松模様の布を置き、その上を一定のルールに従ってマーカーを動かしていました。



Derek J. de Solla Priceによると、Antikytheraのメカニズムは最古の機械式アナログ「コンピュータ」であると考えられている。1901年にギリシャのアンティキティラ島とクレタ島の間にあるアンティキティラ島沖の沈没船で発見され、紀元前100年頃のものとされている。アンティキュテラのメカニズムと同等の複雑さを持つ装置が再び登場するのは、1000年後のことでした。

天文学や航海のために、計算や測定のための多くの機械的な補助装置が作られました。平面球は、11世紀初頭にAbū Rayhān al-Bīrūnīによって発明された星図である。 アストロラベはヘレニズム世界で紀元前1世紀か2世紀に発明されたもので、ヒッパルコスに帰属することが多い。平面球とディオプトラを組み合わせたアストロレーベは、球体天文学におけるさまざまな種類の問題を解くことができるアナログコンピュータであった。機械式の暦計算機と歯車車を組み込んだアストロレーベは、1235年にペルシャのイスファハンのアビ・バクルによって発明された 。 アブー・レイハン・アル・ビフルニ（Abū Rayhān al-Bīrūnī）は、最初の機械式歯車式太陰太陽暦アストロレーベを発明した 。

セクターは、比例、三角法、乗法、除法、および二乗や立方体の根などの様々な関数の問題を解くために使用される計算機であり、16世紀後半に開発され、砲術、測量、航海に応用された。

平面計は、閉じた図形の上を機械的になぞることで面積を計算する手動式の機器でした。



スライドルールは、対数の概念が発表されて間もない1620年～1630年頃に発明されました。これは、乗算や除算を行うための手操作式のアナログコンピュータです。スライドルールの開発が進むにつれ、追加されたスケールは、逆数、二乗と平方根、立方体と立方根、さらには対数や指数などの超越的な関数、円と双曲の三角法、その他の関数を提供しました。軽飛行機の時間や距離の計算に使われるE6B円スライドルールのように、日常的な計算を素早く行うために、特殊な目盛りのついたスライドルールが今でも使われています。

1770年代、スイスの時計師ピエール・ジャケ＝ドロズは、羽ペンを持って文字を書くことができる機械人形（オートマトン）を作りました。内部の車輪の数と順序を変えることで、異なる文字、それゆえに異なるメッセージを作り出すことができる。事実上、人形は機械的に命令を読み取るように「プログラム」されていたのです。他の2つの複雑な機械とともに、この人形はスイスのヌーシャテル美術館にあり、現在も稼働している。

1872年にウィリアム・トムソン卿によって発明された潮汐予測機は、浅瀬での航海に大いに役立ちました。これは、滑車とワイヤーのシステムを使用して、特定の場所で設定された期間の予測潮位を自動的に計算しました。

微分分析装置は、積分によって微分方程式を解くように設計された機械式アナログコンピュータで、積分を実行するために車輪とディスクのメカニズムを使用していました。1876年、ケルビン卿はすでにこのような計算機の建設の可能性について議論していたが、ボールとディスクの積分器の限られた出力トルクに阻まれていた。トルク増幅器は、これらの機械の動作を可能にした進歩であった。1920年代に入ると、Vannevar Bushらが機械式差動分析器を開発した。



## 最初のコンピューティングデバイス

チャールズ・バベッジ（Charles Babbage）は、イギリスの機械技師であり多面性を持つ人物であり、プログラマブル・コンピュータの概念を考案しました。コンピュータの父」と呼ばれている バベッジは、19世紀初頭に最初の機械式コンピュータを構想し、発明した。航海計算を支援するために設計された革命的な差分エンジンに取り組んだ後、1833 年には、より一般的な設計である分析エンジンが可能であることに気付きました。プログラムとデータの入力は、ジャカード織機のような機械織機を指示するために当時使用されていた方法であるパンチングカードを介して機械に提供されることになりました。出力には、プリンタ、カーブプロッタ、ベルを備えていました。また、カードに数字をパンチングして後から読み込ませることも可能でした。エンジンには演算論理ユニット、条件分岐やループの形での制御フロー、統合メモリが組み込まれており、現代用語でチューリング完全と表現できる汎用コンピュータの最初の設計となった。

このマシンは、その時代の約1世紀先を行っていました。彼の機械の部品はすべて手作業で作られなければなりませんでした - これは何千もの部品を持つ装置にとって大きな問題でした。最終的には、イギリス政府の資金提供停止の決定により、このプロジェクトは解散しました。バベッジが分析エンジンを完成させることができなかったのは、政治的にも財政的にも困難であったことと、高度化するコンピュータを開発し、誰よりも早く先に進みたいという彼の願望が主な原因であったと考えられます。それにもかかわらず、彼の息子であるヘンリー・バベッジは、1888年に分析エンジンの計算ユニット（ミル）の簡略化されたバージョンを完成させました。1906年には、表の計算に使用することに成功しました。



![img](https://upload.wikimedia.org/wikipedia/commons/6/6a/LondonScienceMuseumsReplicaDifferenceEngine.jpg)

バベッジの差分エンジンの一部。



### 分析エンジン

https://en.wikipedia.org/wiki/Analytical_Engine

分析エンジンは、イギリスの数学者でありコンピュータのパイオニアであるチャールズ・バベッジによって設計された機械式汎用コンピュータの提案である[2][3]。 よりシンプルな機械式コンピュータのために設計されたバベッジの差分エンジンの後継として、1837年に最初に記述された[4]。

Analytical Engine は、算術論理ユニット、条件分岐やループの形での制御フロー、統合メモリを組み込み、現代用語でチューリング完全と表現できる汎用コンピュータの最初の設計となりました[5][6]。 言い換えれば、Analytical Engine の論理構造は、電子時代のコンピュータ設計を支配してきたものと本質的に同じでした[3]。 Analytical Engine は、チャールズ・バベッジの最も成功した業績の 1 つです[7] [8]。

バベッジは、主任技術者との対立や資金不足のため、どの機械も完成させることができませんでした[7][8]。 バベッジが1837年に先駆的な「Analytical Engine」を提案してから1世紀以上が経過した1941年に、最初の汎用コンピュータである「Z3」が完成したのは、それが初めてでした[3]。 

![img](https://upload.wikimedia.org/wikipedia/commons/a/ac/AnalyticalMachine_Babbage_London.jpg)

![img](https://upload.wikimedia.org/wikipedia/commons/0/0d/PunchedCardsAnalyticalEngine.jpg)



#### 設計

バベッジが最初に試みた機械的計算装置である差分エンジンは、有限差分を評価して近似多項式を作成することで対数や三角関数を集計するために設計された特別な目的の機械であった。この機械の建設は完成しなかった; バベッジは彼の主任技術者であるジョセフ・クレメントと対立し、最終的にイギリス政府はこのプロジェクトへの資金提供を取り下げた[9][10][11]。

このプロジェクトの間、バベッジは、より一般的な設計である「分析エンジン」が可能であることに気付きました[9]。 分析エンジンの設計作業は、1833年頃に開始されました[12][4]。

プログラム（「式」）とデータ[13][9]からなる入力は、当時ジャカード織機のような機械織機に使用されていた方法であるパンチングカードを介して機械に提供されることになっていた[14]。 出力のために、機械はプリンタ、カーブプロッタ、ベルを備えていた[9]。 機械はまた、後に読み込まれるようにカードに数字をパンチングすることも可能であった。この機械は通常のベース10固定小数点演算を採用していた[9]。

それぞれ40桁の10進数[15]の数字を1,000個（約16.2kB）保持することができるストア（つまりメモリ）が予定されていた。算術ユニット（「ミル」）は、4つの算術演算のすべてに加えて、比較や平方根などの演算を実行することができる。 [16] 当初（1838年）は、長いストアが片側に出ている一般的な円形のレイアウトで、それ自体に湾曲した差分エンジンとして構想されていた。 [17] 後の図面(1858年)では、正則化されたグリッドレイアウトが描かれている。[18] 現代のコンピュータの中央処理装置(CPU)のように、このミルは、「バレル」と呼ばれる回転ドラムに挿入されたペグの形で保存され、ユーザーのプログラムが指定するより複雑な命令のいくつかを実行するために、独自の内部手続きに依存していた[7]。

ユーザーが使用するプログラミング言語は、現代のアセンブリ言語に似ていました。ループと条件分岐が可能なので、考え出された言語は後にアラン・チューリングによって定義されたチューリング・コンプリートなものになります。3種類の異なるタイプのパンチカードが使用されました。1つは算術演算用、1つは数値定数用、もう1つはロードとストアの演算用で、ストアから算術演算ユニットに数値を転送したり、戻ったりすることができます。3種類のカードには3つの別々のリーダーがありました。バベッジは1837年から1840年の間に約2ダースの分析エンジン用プログラムを開発し、その後1つのプログラムを開発した[14][19]。

1842 年、イタリアの数学者ルイジ・フェデリコ・メナブレアが、バベッジの講義を基にしたエンジンの説明をフランス語で発表しました。1843年、この記述は英語に翻訳され、8年前にエンジンに興味を持ったエイダ・ラブレスによって広範囲に注釈が付けられました。この機械を使ってベルヌーイ数を計算する方法を含むメナブレアの論文への彼女の付加が評価され、（広く最初の完全なコンピュータプログラムであると考えられている）彼女は最初のコンピュータプログラマーとして記述されている。

#### 建設

バベッジは晩年、この機械の簡易版を作る方法を模索し、1871年に亡くなるまでにその一部を組み立てた[7][1][22]。

1878 年、英国科学振興協会の委員会は、分析エンジンを「機械的創意工夫の驚異」と評しましたが、その建設には反対するよう勧告しました。委員会はこの機械の有用性と価値を認めていましたが、それを構築するためのコストを見積もることができず、構築後に機械が正しく機能するかどうかも不明でした[23][24]。

1880年から1910年まで断続的に[25] バベッジの息子ヘンリー・プレボスト・バベッジが工場の一部と印刷装置を建設していた。1910年には円周率の倍数の（欠陥のある）リストを計算できるようになった[26]。(このセクションの一般的な画像では、これがミル全体、あるいはエンジン全体であるかのように誤表示されていることがある)。ヘンリー・バベッジの「分析エンジンミル」は、ロンドンの科学博物館に展示されています[21]。 ヘンリーはまた、フルエンジンのデモ版を作ることを提案しました。"そのようなバージョンでは、それぞれ25桁の数字を20個操作することができ、それらの数字を使って何をするように指示することができるかは、まだ印象的なものになるでしょう。"それはカードと時間の問題でしかない」と1888年にヘンリー・バベッジは書いています。「...そして、必要に応じて（2万枚の）カードを数学者の目的のための分析エンジンで使用しない理由はありません」[27]。

1991年、ロンドン科学博物館はバベッジの差分エンジンNo.2の完全かつ実用的な標本を製作しました。 この機械はバベッジが利用可能であったであろう材料と工学的な許容範囲を使用して製作されており、バベッジの設計は当時の製造技術を使用して製作することができなかったのではないかという意見を払拭しています[28]。

2010 年 10 月、John Graham-Cumming 氏は、バベッジの計画の歴史的・学術的な研究を真剣に行うために「一般公募」による資金調達を行う「Plan 28」キャンペーンを開始しました。 バベッジのオリジナルの設計図から一貫した理解が得られなかったため、2016 年 5 月の時点では実際の構築は試みられていませんでした。特に、Lovelace の Bernoulli プログラムに必要とされるインデックス付き変数を扱えるかどうかは不明でした[31]。 2017 年までに、「Plan 28」の取り組みでは、すべてのカタログ化された資料の検索可能なデータベースが利用可能になり、バベッジの膨大な量の走り書き帳の初期レビューが完了したことが報告されました[32]。

#### 命令セット

バベッジは、現代のプロセッサのマニュアルのように、エンジンのための明示的な命令セットを書き留めたことは知られていません。
その代わりに、バベッジは自分のプログラムを実行中の状態のリストとして示し、各ステップでどの演算子が実行されるかを示し、制御フローがどのように導かれるかをほとんど示していませんでした。

アラン・G・ブロムリーは、カード・デッキが、条件分岐の関数として、前方と後方の方向に読めると仮定しています。

...カードは、順方向と逆方向に移動するように命令することができます（したがって、ループするために）....[14]

1845年に初めて、ユーザープログラムのループ制御に有効なシステムをはじめとする様々なサービス機能のユーザー操作が導入された。操作と可変カードの回転方向がどのように指定されているのかは示されていない。他の証拠がないため、私は、バベッジのサンプルプログラムで使用されているループを実装するために必要なように、操作カードと変数カードの両方が後ろ向きにしか回せないという最小限のデフォルトの仮定を採用しなければなりませんでした。運動の方向をユーザの制御下に置くことに機械的またはマイクロプログラミングの難しさはないでしょう[33]。

エンジンのエミュレータでは、Fourmilabは言う。

エンジンのカードリーダーは、最初から最後までチェーン状に並んだカードを処理するだけではありません。さらに、読み込んだカードに指示されて、ミルのランアップレバーが作動しているかどうかで、カードチェーンを前進させ、その間のカードをスキップしたり、後退させたりして、先に読み込んだカードを再び処理することもできるのです。

このエミュレータは，バベッジの原作に基づいたものではなく，作者が作成したシンボリック命令セットを提供しているが，これはバベッジの原作に基づいたものではない．例えば，階乗プログラムは次のように書かれています．



## アナログコンピュータ

20世紀前半、多くの科学計算のニーズは、問題の直接機械的または電気的モデルを計算の基礎として使用する、ますます洗練されたアナログ・コンピュータによって満たされていました。しかし、これらはプログラム可能ではなく、一般的に現代のデジタルコンピュータのような汎用性と精度を欠いていた。 最初の現代的なアナログコンピュータは、1872年にSir William Thomsonによって発明された潮汐予測機であった。微分分析器は、ホイールとディスクのメカニズムを使用して微分方程式を積分して解くように設計された機械式アナログコンピュータで、1876年に、より有名なケルビン卿の弟であるジェームズ・トムソンによって構想された。

機械的アナログ・コンピューティングの技術は、1927 年から MIT で H. L. Hazen と Vannevar Bush によって開発されたディファレンシャル・アナライザーで頂点に達しました。これは、James Thomsonの機械的な積分器とH. W. Niemanによって発明されたトルク増幅器の上に構築されました。これらの装置の陳腐化が明らかになる前に、十数台の装置が作られた。1950年代までに、デジタル電子コンピュータの成功は、ほとんどのアナログコンピューティングマシンの終わりを告げたが、アナログコンピュータは1950年代に教育（制御システム）や航空機（スライドルール）などのいくつかの専門的なアプリケーションで使用されたままであった。



## デジタルコンピュータ

### 電気機械

1938年までに、アメリカ海軍は潜水艦に搭載できる小型の電気機械式アナログコンピュータを開発していました。これが魚雷データコンピュータで、三角法を使って、動く標的に魚雷を発射する問題を解決しました。第二次世界大戦中には、他の国でも同様の装置が開発されました。

初期のデジタルコンピュータは電気機械式で、電気スイッチが機械式リレーを駆動して計算を行いました。これらのデバイスは動作速度が低く、最終的には、もともと真空管を使用していたはるかに高速な全電子コンピュータに取って代わられました。1939年にドイツ人エンジニアのKonrad Zuseによって作成されたZ2は、電気機械式リレーコンピュータの初期の例の1つであった。

1941 年、Zuse はそれ以前の機械に続いて、世界初の動作する電気機械式プログラム可能な全自動デジタルコンピュータ Z3 を発表した 。 Z3 は 2000 個のリレーを搭載し、約 5～10 Hz のクロック周波数で動作する 22 ビットのワード長を実装した 。これはいくつかの点で現代の機械に酷似しており、浮動小数点数のような数多くの進歩を開拓していた。実装が困難な10進法（チャールズ・バベッジの初期の設計で使用されていた）ではなく、2進法を使用することは、当時利用可能な技術を考えると、ズースの機械の構築が容易であり、潜在的に信頼性が高いことを意味していた。



### 真空管とデジタル電子回路

純粋な電子回路素子はすぐに機械式や電気機械式の等価物に取って代わられ、同時にデジタル計算がアナログに取って代わられました。1930年代にロンドンの郵便局研究所で働いていたエンジニアのトミー・フラワーズは、電話交換機に電子機器を使用する可能性を探り始めました。1934年に彼が作った実験装置は5年後に稼働し、数千本の真空管を使用して電話交換ネットワークの一部を電子データ処理システムに変換した。 米国では、アイオワ州立大学のジョン・ヴィンセント・アタナソフとクリフォード・E・ベリーが1942年にアタナソフ・ベリー・コンピュータ（ABC）を開発してテストした。 この設計もまた全電子式で、約300本の真空管を使用し、メモリ用に機械的に回転するドラムにコンデンサが固定されていた。



第二次世界大戦中、ブレッチリー・パークにいたイギリス人は、暗号化されたドイツ軍の通信を解読することに多くの成功を収めた。ドイツの暗号化マシンであるエニグマは、女性がしばしば実行していた電気機械爆弾の助けを借りて最初に攻撃された より洗練されたドイツのローレンツ SZ 40/42 マシンを解読するために、マックス・ニューマンと彼の同僚たちは、コロッサスを作るためにフラワーズに依頼した。  彼は1943年2月初旬から11ヶ月間、最初のコロッサスの設計と建造に費やした 1943年12月の機能テストの後、コロッサスはブレッチリーパークに出荷され、そこで1944年1月18日に納入され、2月5日に最初のメッセージを攻撃した。

コロッサスは世界初の電子デジタル・プログラマブル・コンピュータであった。紙テープ入力があり、データに対して様々な論理演算を実行するように設定することが可能であったが、チューリング完全ではなかった。9台のMk II Colossiが製造された（Mk IはMk IIに改造され、合計10台が製造された）。コロッサス・マークIには1,500個のサーミオンバルブ（チューブ）が含まれていたが、2,400個のバルブを持つマークIIはマークIよりも5倍速く、操作もシンプルで、復号処理を大幅に高速化した。



ENIAC (Electronic Numerical Integrator and Computer)は、米国で最初に作られた電子的にプログラム可能なコンピュータでした。ENIACはコロッサスに似ていましたが、より高速で柔軟性があり、チューリング・コンプリートでした。コロッサスと同様に、ENIACの「プログラム」はパッチケーブルとスイッチの状態によって定義され、後に登場した保存されたプログラムの電子機械とはかけ離れたものでした。一度プログラムが書かれたら、それは機械的にプラグやスイッチを手動でリセットしてマシンにセットしなければなりませんでした。ENIACのプログラマーは6人の女性で、しばしば "ENIACガールズ "としてまとめて知られていた。

それは、多くの複雑な問題のためにプログラムされる能力と電子機器の高速性を組み合わせたものです。それは、1秒間に5000回、他のどのマシンよりも1000倍速く足し算や引き算をすることができました。また、乗算、除算、平方根へのモジュールを持っていた。高速メモリは20ワード（約80バイト）に制限されていました。ペンシルバニア大学のJohn MauchlyとJ. Presper Eckertの指導の下で建設されたENIACの開発と建設は、1943年から1945年末のフル稼働まで続きました。この機械は重量30トンの巨大なもので、200キロワットの電力を使用し、18,000本以上の真空管、1,500個以上のリレー、数十万個の抵抗器、コンデンサ、インダクタが含まれていた。



## 現代のコンピュータ

### 現代のコンピュータの概念

現代のコンピュータの原理は、アラン・チューリングによって1936年の論文 On Computable Numbersで提案されました。チューリングは「ユニバーサル・コンピューティング・マシン」と呼ばれ、現在ではユニバーサル・チューリング・マシンとして知られているシンプルな装置を提案しました。彼は、そのような機械がテープに保存された命令（プログラム）を実行することで計算可能なものなら何でも計算できることを証明し、機械をプログラム可能にした。チューリングの設計の基本的な概念は、計算のためのすべての命令がメモリに格納されているストアド・プログラムである。フォン・ノイマンは、現代のコンピュータの中心的な概念がこの論文によるものであることを認めています。 チューリング・マシンは、今日まで計算理論の研究の中心的な対象となっています。現代のコンピュータは、メモリの有限性による制限を除けば、チューリング・コンプリート、つまり普遍的なチューリング・マシンと同等のアルゴリズム実行能力を持っていると言われています。



### ストアドプログラム

初期の計算機は固定されたプログラムを持っていた。その機能を変更するには、マシンの再配線や再構築が必要であったが、ストアド・プログラム・コンピュータの提案により、これが変わった。ストアド・プログラム・コンピュータは、設計によって命令セットを含み、計算を詳細に記述した命令セット（プログラム）をメモリに格納することができる。ストアド・プログラム・コンピュータの理論的基礎は、アラン・チューリングによって1936年に発表されました。1945年、チューリングは国立物理研究所に入り、電子的なストアド・プログラム・デジタル・コンピュータの開発に取り組み始めました。彼の1945年の報告書「提案された電子計算機」は、そのようなデバイスのための最初の仕様でした。ペンシルバニア大学のジョン・フォン・ノイマンもまた、1945年にEDVACに関する報告書の第一稿を回覧しています。

マンチェスター・ベイビーは、世界初のストアド・プログラム・コンピュータであった。マンチェスターのビクトリア大学でフレデリック・C・ウィリアムズ（Frederic C. Williams）、トム・キルバーン（Tom Kilburn）、ジェフ・トッティル（Geoff Tootill）によって建設され、1948年6月21日に最初のプログラムが実行された。  このコンピュータは、当時の基準では「小さくて原始的」と考えられていたが、現代の電子コンピュータに不可欠な要素をすべて含んだ最初の作業機であった。グレース・ホッパーはプログラミング言語用のコンパイラを開発した最初の人物である。

このマーク 1 はすぐに、世界初の市販汎用コンピュータである Ferranti Mark 1 のプロトタイプとなった。その後、1953年から1957年の間に少なくとも7台のマシンが納入され、そのうちの1台はアムステルダムのシェル研究所に納入された。 1947年10月、英国のケータリング会社J.ライアンズ＆カンパニーの取締役は、コンピュータの商業開発を促進するために積極的な役割を果たすことを決定した。LEO Iコンピュータは1951年4月に稼働を開始し、世界初の定型的なオフィス・コンピュータ・ジョブを実行した。



### トランジスタ

電界効果トランジスタの概念は、1925年にJulius Edgar Lilienfeldによって提案されました。ジョン・バーディーンとウォルター・ブラッテンは、ベル研究所のウィリアム・ショックレーの下で働いていたときに、1947年に最初の実用的なトランジスタである点接触型トランジスタを製造し、その後1948年にショックレーのバイポーラ接合型トランジスタが製造されました。 1955年以降、トランジスタはコンピュータの設計において真空管に取って代わり、「第2世代」のコンピュータを生み出しました。真空管と比較して、トランジスタには多くの利点があります。ジャンクショントランジスタは真空管よりも信頼性が高く、耐用年数も長く、無期限でした。トランジスタ化されたコンピュータは、比較的コンパクトなスペースに数万個のバイナリ論理回路を格納することができました。しかし、初期のジャンクショントランジスタは、量産ベースでの製造が困難な比較的かさばるデバイスであったため、多くの特殊なアプリケーションに限定されていた。

マンチェスター大学では，トム・キルバーンの率いるチームが，バルブの代わりに新しく開発されたトランジスターを使用した機械を設計し，製造した． 彼らの最初のトランジスター化された世界初のコンピュータは，1953 年までに稼働し，1955 年 4 月に第 2 版が完成した．しかし、このマシンは125 kHzのクロック波形を生成するためにバルブを使用し、磁気ドラムメモリの読み書きを行う回路にもバルブを使用していたので、最初の完全にトランジスタ化されたコンピュータではなかった。この点では、1955年にハーウェルの原子力研究施設の電子工学部門によって製作されたハーウェルCADETの方が優れている。

MOSトランジスタとしても知られる金属酸化シリコン電界効果トランジスタ（MOSFET）は、1959年にBell LabsでMohamed M. AtallaとDawon Kahngによって発明された。 このトランジスタは、幅広い用途向けに小型化・量産が可能な最初の真の小型トランジスタであった。 高いスケーラビリティと、バイポーラ接合トランジスタよりもはるかに低い消費電力と高密度により、高密度集積回路の構築が可能になった。  また、データ処理だけでなく、メモリセルの記憶素子としても実用化され、コンピュータの磁気コアメモリに代わってMOS半導体メモリが開発された 。 MOSFETはマイクロコンピュータ革命につながり、コンピュータ革命の原動力となった MOSFETは、コンピュータで最も広く使われているトランジスタであり、デジタルエレクトロニクスの基本的な構成要素である。



### 集積回路

コンピューティング能力の次の大きな進歩は、集積回路 (IC) の出現によってもたらされました。集積回路のアイデアは、国防省の王立レーダー施設に勤務していたレーダー科学者、Geoffrey W.A. Dummerによって最初に考案されました。ダマーは、1952年5月7日にワシントンD.C.で開催された「品質の高い電子部品の進歩に関するシンポジウム」で、集積回路の最初の公開説明を行いました。

最初の実用的な IC は、テキサス・インスツルメンツの Jack Kilby とフェアチャイルド・セミコンダクターの Robert Noyce によって発明された 。 Kilby は 1958 年 7 月に集積回路に関する最初のアイデアを記録し、1958 年 9 月 12 日に最初の実用的な集積化例のデモンストレーションに成功した。 しかし、キルビーの発明はモノリシック集積回路（IC）チップではなく、ハイブリッド集積回路（ハイブリッドIC）であった。

ノイスもまた、キルビーより半年遅れで集積回路の独自のアイデアを思いついた 。 ノイスの発明は、最初の真のモノリシックICチップであった 。フェアチャイルド・セミコンダクター社で製造されたこのチップはシリコン製であったが、キルビーのチップはゲルマニウム製であった。ノイスのモノリシックICは、1959年初頭に同僚のJean Hoerniによって開発された平面プロセスを使用して製造された。プラナープロセスは、1950年代後半にBell LabsでMohamed Atallaによって開発されたシリコン表面のパッシベーションと熱酸化プロセスに基づいていた。

現代のモノリシックICは、MOSFET(MOSトランジスタ)から作られたMOS(金属酸化膜半導体)集積回路が主である。 1959年に最初のMOSFETがBell LabsのMohamed AtallaとDawon Kahngによって発明された後、 Atallaは1960年にMOS集積回路の概念を最初に提案し、続いてKahngは1961年にMOSトランジスタの製造の容易さが集積回路に有用であることを指摘した。  最も早く実験的に作製されたMOS ICは、1962年にRCAでFred HeimanとSteven Hofsteinによって作製された16トランジスタチップであった。 その後、ゼネラル・マイクロエレクトロニクス社は、ロバート・ノーマンによって開発された最初の商用MOS ICを1964年に発表した。 1967年にベル研究所のロバート・カーウィン、ドナルド・クライン、ジョン・サレースによってセルフアラインドゲート（シリコンゲート）MOSトランジスタが開発されたのに続き、1968年にフェアチャイルドセミコンダクター社のフェデリコ・ファギンによってセルフアラインドゲートを備えた最初のシリコンゲートMOS ICが開発された。 それ以来、MOSFETは現代のICで最も重要なデバイスコンポーネントとなっている。

MOS集積回路の開発は、マイクロプロセッサの発明につながり、コンピュータの商用および個人使用における爆発的な普及の先駆けとなりました。どのデバイスが最初のマイクロプロセッサであったかについては、「マイクロプロセッサ」という用語の正確な定義が一致していないこともあり、論争の的となっていますが、最初のシングルチップ・マイクロプロセッサはIntel であり、Federico FagginがIntelのTed Hoff、Shima Masatoshi Shima、Stanley Mazorとともに、彼のシリコンゲートMOS IC技術で設計し、実現しました。  1970年代初頭には、MOS IC技術により、1つのチップ上に10,000個以上のトランジスタを集積することが可能になった。

システム・オン・ア・チップ（SoC）は、コインサイズのマイクロチップ（またはチップ）上の完全なコンピュータである。内蔵されていない場合、RAMは通常、SoCの真上（パッケージ・オン・パッケージとして知られている）または下（回路基板の反対側）に配置され、フラッシュ・メモリは通常、SoCのすぐ隣に配置されます。1945年のENIAC以来、コンピュータは飛躍的に進歩し、現代のSoCはコインサイズでありながら、ENIACの何十万倍ものパワーを持ち、数十億個のトランジスタを集積し、消費電力はわずか数ワットに抑えられています。



### モバイルコンピュータ

最初のモバイルコンピュータは重く、主電源で動いていました。50ポンドのIBM 5100は初期の例でした。そのようなオズボーン1とコンパックポータブルなどの後のポータブルはかなり軽量であったが、まだコンセントに接続する必要があります。グリッド・コンパスなどの最初のラップトップは、電池を内蔵することでこの要件を取り除いていました。

これらのスマートフォンやタブレットは、さまざまなオペレーティング・システム上で動作し、最近では市場を支配するコンピューティング・デバイスとなりました。 これらは、コインサイズのマイクロチップ上の完全なコンピュータであるシステム・オン・ア・チップ（SoC）を搭載しています。



|                                                              |                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| First generation (mechanical/electromechanical)              | Calculators                                                  | [Pascal's calculator](https://en.wikipedia.org/wiki/Pascal's_calculator), [Arithmometer](https://en.wikipedia.org/wiki/Arithmometer), [Difference engine](https://en.wikipedia.org/wiki/Difference_engine), [Quevedo's analytical machines](https://en.wikipedia.org/wiki/Leonardo_Torres_y_Quevedo#Analytical_machines) |
| Programmable devices                                         | [Jacquard loom](https://en.wikipedia.org/wiki/Jacquard_loom), [Analytical engine](https://en.wikipedia.org/wiki/Analytical_engine), [IBM ASCC/Harvard Mark I](https://en.wikipedia.org/wiki/Harvard_Mark_I), [Harvard Mark II](https://en.wikipedia.org/wiki/Harvard_Mark_II), [IBM SSEC](https://en.wikipedia.org/wiki/IBM_SSEC), [Z(https://en.wikipedia.org/wiki/Z1_(computer)), [Z(https://en.wikipedia.org/wiki/Z2_(computer)), [Z(https://en.wikipedia.org/wiki/Z3_(computer)) |                                                              |
| Second generation (vacuum tubes)                             | Calculators                                                  | [Atanasoff–Berry Computer](https://en.wikipedia.org/wiki/Atanasoff–Berry_Computer), [IBM (https://en.wikipedia.org/wiki/IBM_604), [UNIVAC (https://en.wikipedia.org/wiki/Remington_Rand_409), [UNIVAC (https://en.wikipedia.org/wiki/Remington_Rand_409) |
| [Programmable devices](https://en.wikipedia.org/wiki/List_of_vacuum_tube_computers) | [Colossus](https://en.wikipedia.org/wiki/Colossus_computer), [ENIAC](https://en.wikipedia.org/wiki/ENIAC), [Manchester Baby](https://en.wikipedia.org/wiki/Manchester_Baby), [EDSAC](https://en.wikipedia.org/wiki/Electronic_Delay_Storage_Automatic_Calculator), [Manchester Mark (https://en.wikipedia.org/wiki/Manchester_Mark_1), [Ferranti Pegasus](https://en.wikipedia.org/wiki/Ferranti_Pegasus), [Ferranti Mercury](https://en.wikipedia.org/wiki/Ferranti_Mercury), [CSIRAC](https://en.wikipedia.org/wiki/CSIRAC), [EDVAC](https://en.wikipedia.org/wiki/EDVAC), [UNIVAC I](https://en.wikipedia.org/wiki/UNIVAC_I), [IBM (https://en.wikipedia.org/wiki/IBM_701), [IBM (https://en.wikipedia.org/wiki/IBM_702), [IBM (https://en.wikipedia.org/wiki/IBM_650), [Z(https://en.wikipedia.org/wiki/Z22_(computer)) |                                                              |
| Third generation (discrete [transistors](https://en.wikipedia.org/wiki/Transistor) and SSI, MSI, LSI [integrated circuits](https://en.wikipedia.org/wiki/Integrated_circuit)) | [Mainframes](https://en.wikipedia.org/wiki/Mainframe_computer) | [IBM (https://en.wikipedia.org/wiki/IBM_7090), [IBM (https://en.wikipedia.org/wiki/IBM_7080), [IBM System/(https://en.wikipedia.org/wiki/IBM_System/360), [BUNCH](https://en.wikipedia.org/wiki/BUNCH) |
| [Minicomputer](https://en.wikipedia.org/wiki/Minicomputer)   | [HP 2116A](https://en.wikipedia.org/wiki/HP_2100), [IBM System/(https://en.wikipedia.org/wiki/IBM_System/32), [IBM System/(https://en.wikipedia.org/wiki/IBM_System/36), [LINC](https://en.wikipedia.org/wiki/LINC), [PDP-(https://en.wikipedia.org/wiki/PDP-8), [PDP-(https://en.wikipedia.org/wiki/PDP-11) |                                                              |
| [Desktop Computer](https://en.wikipedia.org/wiki/Desktop_Computer) | [HP (https://en.wikipedia.org/wiki/HP_9100)             |                                                              |
| Fourth generation ([VLSI](https://en.wikipedia.org/wiki/VLSI) integrated circuits) | Minicomputer                                                 | [VAX](https://en.wikipedia.org/wiki/VAX), [IBM System i](https://en.wikipedia.org/wiki/IBM_System_i) |
| [4-bit](https://en.wikipedia.org/wiki/4-bit) microcomputer   | [Intel (https://en.wikipedia.org/wiki/Intel_4004), [Intel (https://en.wikipedia.org/wiki/Intel_4040) |                                                              |
| [8-bit](https://en.wikipedia.org/wiki/8-bit) microcomputer   | [Intel (https://en.wikipedia.org/wiki/Intel_8008), [Intel (https://en.wikipedia.org/wiki/Intel_8080), [Motorola (https://en.wikipedia.org/wiki/Motorola_6800), [Motorola (https://en.wikipedia.org/wiki/Motorola_6809), [MOS Technology (https://en.wikipedia.org/wiki/MOS_Technology_6502), [Zilog Z(https://en.wikipedia.org/wiki/Zilog_Z80) |                                                              |
| [16-bit](https://en.wikipedia.org/wiki/16-bit) microcomputer | [Intel (https://en.wikipedia.org/wiki/Intel_8088), [Zilog Z(https://en.wikipedia.org/wiki/Zilog_Z8000), [WDC 65816/(https://en.wikipedia.org/wiki/WDC_65816/65802) |                                                              |
| [32-bit](https://en.wikipedia.org/wiki/32-bit) microcomputer | [Intel (https://en.wikipedia.org/wiki/Intel_80386), [Pentium](https://en.wikipedia.org/wiki/Pentium), [Motorola (https://en.wikipedia.org/wiki/Motorola_68000), [ARM](https://en.wikipedia.org/wiki/ARMv7) |                                                              |
| [64-bit](https://en.wikipedia.org/wiki/64-bit) microcomputer[[93\]](https://en.wikipedia.org/wiki/Computer#cite_note-93) | [Alpha](https://en.wikipedia.org/wiki/DEC_Alpha), [MIPS](https://en.wikipedia.org/wiki/MIPS_architecture), [PA-RISC](https://en.wikipedia.org/wiki/PA-RISC), [PowerPC](https://en.wikipedia.org/wiki/PowerPC), [SPARC](https://en.wikipedia.org/wiki/SPARC), [x86-(https://en.wikipedia.org/wiki/X86-64), [ARMv8-A](https://en.wikipedia.org/wiki/ARMv8-A) |                                                              |
| [Embedded computer](https://en.wikipedia.org/wiki/Embedded_system) | [Intel (https://en.wikipedia.org/wiki/Intel_8048), [Intel (https://en.wikipedia.org/wiki/Intel_8051) |                                                              |
| Personal computer                                            | [Desktop computer](https://en.wikipedia.org/wiki/Desktop_computer), [Home computer](https://en.wikipedia.org/wiki/Home_computer), [Laptop](https://en.wikipedia.org/wiki/Laptop) computer, [Personal digital assistant](https://en.wikipedia.org/wiki/Personal_digital_assistant) (PDA), [Portable computer](https://en.wikipedia.org/wiki/Portable_computer), [Tablet PC](https://en.wikipedia.org/wiki/Tablet_computer), [Wearable computer](https://en.wikipedia.org/wiki/Wearable_computer) |                                                              |
| Theoretical/experimental                                     | [Quantum computer](https://en.wikipedia.org/wiki/Quantum_computer), [Chemical computer](https://en.wikipedia.org/wiki/Chemical_computer), [DNA computing](https://en.wikipedia.org/wiki/DNA_computing), [Optical computer](https://en.wikipedia.org/wiki/Photonic_computing), [Spintronics](https://en.wikipedia.org/wiki/Spintronics)-based computer, [Wetware/Organic computer](https://en.wikipedia.org/wiki/Wetware_computer) |                                                              |



# ハードウェア

ハードウェアという用語は、有形の物理的なオブジェクトであるコンピュータのすべての部分をカバーしています。回路、コンピュータチップ、グラフィックカード、サウンドカード、メモリ（RAM）、マザーボード、ディスプレイ、電源、ケーブル、キーボード、プリンタ、マウスなどの入力デバイスはすべてハードウェアです。



## Control unit

制御装置（しばしば制御システムまたは中央制御装置と呼ばれる）は、コンピュータの様々なコンポーネントを管理し、プログラム命令を読み取って解釈（デコード）し、それをコンピュータの他の部分を活性化する制御信号に変換する。 高度なコンピュータの制御システムは、パフォーマンスを向上させるために、いくつかの命令の実行順序を変更することがある。

すべてのCPUに共通する重要なコンポーネントは、プログラムカウンタであり、メモリ内のどの位置から次の命令を読み出すかを追跡する特別なメモリセル（レジスタ）である。

制御系の機能は以下のようになっています。

1. プログラムカウンタが示すセルから次の命令のコードを読み出す。
2. 命令の数値コードを他のシステムの命令や信号にデコードします。
3. 次の命令を指すようにプログラムカウンタをインクリメントします。
4. メモリ内のセル(または入力デバイス)から命令が必要とするデータを読み込みます。この必要なデータの場所は、通常、命令コードの中に格納されています。
5. 必要なデータをALUやレジスタに供給します。
6. 命令が完了するためにALUや特殊なハードウェアを必要とする場合は、要求された操作を実行するようにハードウェアに指示します。
7. ALUからの結果をメモリやレジスタ、あるいは出力デバイスに書き出します。
8. ステップ(1)に戻ります。

プログラムカウンタは（概念的には）単なるメモリセルのセットなので、ALUでの計算で変更することができます。プログラムカウンタに１００を加えると、次の命令はプログラムの１００個下の位置から読み出されます。プログラムカウンタを変更する命令は、しばしば「ジャンプ」と呼ばれ、ループ（コンピュータによって繰り返される命令）や条件付き命令の実行を可能にします（どちらも制御フローの例です）。

制御ユニットが命令を処理するために通過する一連の操作は、それ自体が短いコンピュータプログラムのようなものであり、実際、より複雑なCPU設計の中には、マイクロシーケンサと呼ばれる別の小さなコンピュータがあり、これらのイベントをすべて発生させるマイクロコードプログラムを実行しています。



## 中央処理装置（ＣＰＵ）

制御ユニット、ALU、レジスタを総称して中央処理装置(CPU)と呼ばれています。初期のCPUは、多くの別個のコンポーネントで構成されていました。1970年代以降、CPUは通常、マイクロプロセッサと呼ばれる単一のMOS集積回路チップで構成されています。



## 算術論理ユニット(ALU)

ALU は算術と論理の 2 つのクラスの演算を行うことができます。 特定の ALU がサポートする算術演算は、足し算と引き算に限定される場合もあれば、乗算、除算、サイン、コサインなどの三角関数、平方根などを含む場合もあります。また、整数でしか操作できないものもあれば、浮動小数点を使って実数を表現するものもありますが、精度は限られています。しかし、最も単純な操作だけを実行できるコンピュータであれば、より複雑な操作を単純なステップに分解して実行できるようにプログラムすることができます。したがって、どんなコンピュータでも、どんな算術演算を実行するようにプログラムすることができますが、ALUが演算を直接サポートしていない場合は、演算に時間がかかります。また、ALUは数値を比較し、一方が他方と等しいか、他方より大きいか、他方より小さいかに応じて真偽値（trueかfalse）を返すことができます（「64は65より大きいか？論理演算にはブール論理が含まれます。AND、OR、XOR、NOT。これらは、複雑な条件文を作成したり、ブーリアンロジックを処理したりするのに便利です。

スーパースカラコンピュータには複数のALUが含まれており、複数の命令を同時に処理することができます。



## メモリ

1960年代には、半導体メモリ（MOSメモリセルを使用）に取って代わられるまで、磁気コアメモリ（磁気コアを使用）がコンピュータのメモリとして採用されていました。
コンピュータのメモリは、数字を入れたり、読み込んだりできるセルのリストとして見ることができます。各セルには番号が付けられた「アドレス」があり、1つの番号を格納することができます。コンピュータは、"１２３番の数字を１３５７番のセルに入れる "ように指示したり、"１３５７番のセルにある数字を２４６８番のセルにある数字に足して、１５９５番のセルに答えを入れる "ように指示したりすることができる。メモリに格納されている情報は、実質的に何でも表すことができます。文字、数字、コンピュータの命令でさえも、同じように簡単にメモリに入れることができます。CPUは異なるタイプの情報を区別しないので、メモリが数字の羅列にしか見えないものに意味を持たせるのはソフトウェアの責任です。

最近のほとんどすべてのコンピュータでは、各メモリセルは8ビット（バイトと呼ばれる）のグループで2進数を格納するように設定されています。各バイトは、0から255まで、または-128から127までの256の数字（28 = 256）を表すことができます。より大きな数値を格納するには、いくつかの連続したバイトを使用することができます（通常、2、4、または8）。負の数が必要な場合は、通常は2の補数表記で格納されます。その他の配置も可能ですが、特殊なアプリケーションや歴史的な文脈以外では通常見られません。コンピュータは、数値で表現できれば、あらゆる種類の情報をメモリに格納することができます。現代のコンピュータは数十億、あるいは数兆バイトのメモリを持っています。

CPUには、レジスタと呼ばれる特別なメモリセルが含まれており、メインメモリ領域よりもはるかに高速に読み書きすることができます。CPUの種類にもよりますが、一般的には2～100個のレジスタがあります。レジスタは、データが必要になるたびにメインメモリにアクセスしなくても済むように、最も頻繁に必要とされるデータ項目に使用されます。データは常に処理されているので、メインメモリ（ALUや制御ユニットに比べて遅いことが多い）にアクセスする必要性を減らすことで、コンピュータの速度を大幅に向上させることができます。

コンピュータのメインメモリには、主に2つの種類があります。



- ランダムアクセスメモリまたはRAM
- よみとり専用メモリ



ＲＡＭはＣＰＵの命令でいつでも読み書きできるが、ＲＯＭにはデータやソフトウェアがあらかじめ搭載されており、決して変わることはないので、ＣＰＵはそこから読み出すことしかできない。ROMは通常、コンピュータの初期起動命令を格納するために使用されます。一般的に、ＲＡＭの内容はコンピュータの電源を切ると消去されますが、ＲＯＭはそのデータを無期限に保持しています。PCでは、ROMにはBIOSと呼ばれる特殊なプログラムが含まれており、コンピュータの電源を入れたり、リセットしたりするたびに、コンピュータのオペレーティングシステムをハードディスクドライブからRAMにロードするように調整されています。ディスクドライブを持たないことが多い組み込みコンピュータでは、必要なソフトウェアはすべてROMに格納されている場合があります。ROMに格納されたソフトウェアは、ソフトウェアというよりもハードウェアのようなものであるため、ファームウェアと呼ばれることが多いです。フラッシュメモリは、電源を切ってもデータを保持するが、書き換え可能であるため、ROMとRAMの区別を曖昧にしている。しかし、それは通常、従来の ROM や RAM よりもはるかに遅いので、その使用は高速が不要なアプリケーションに限定されている。

より洗練されたコンピュータでは、レジスタよりは遅いがメインメモリよりは高速なRAMキャッシュメモリを1つ以上搭載している場合があります。一般的に、この種のキャッシュを搭載したコンピュータは、頻繁に必要とされるデータを自動的にキャッシュに移動させるように設計されており、多くの場合、プログラマの介入を必要としません。



## 入出力（I/O）

I/Oは、コンピュータが外部と情報を交換するための手段である。 コンピュータに入力または出力を提供するデバイスを周辺機器と呼ぶ。 典型的なパーソナルコンピュータでは、周辺機器には、キーボードやマウスなどの入力デバイスと、ディスプレイやプリンタなどの出力デバイスが含まれる。ハードディスクドライブ、フロッピーディスクドライブ、光ディスクドライブは、入力デバイスと出力デバイスの両方として機能する。コンピュータネットワークは、I/Oのもう一つの形態である。I/Oデバイスは、多くの場合、独自のCPUとメモリを持つ、独自の権利で複雑なコンピュータです。グラフィックス処理装置は、3Dグラフィックスを表示するために必要な計算を実行する50以上の小さなコンピュータが含まれている可能性があります[引用が必要]現代のデスクトップコンピュータは、I/Oを実行する際にメインCPUを支援する多くの小さなコンピュータが含まれています。2016年のフラットスクリーンディスプレイには、独自のコンピュータ回路が含まれています。



## マルチタスク

コンピュータはメインメモリに格納された巨大なプログラムを実行しているように見えるかもしれませんが、 システムによっては複数のプログラムを同時に実行しているように見せる必要があります。これはマルチタスク、すなわちコンピュータに各プログラムを順番に実行しているかどうかを迅速に切り替えさせることで実現されます。割り込みの前にどこで実行していたかを記憶することで、コンピュータは後でそのタスクに戻ることができます。複数のプログラムが「同時に」実行されている場合は、割り込み発生器が毎秒数百回の割り込みを発生させ、その都度プログラムを切り替えている可能性があります。現代のコンピュータは人間の知覚よりも数桁速い命令を実行しているので、ある瞬間には1つのプログラムしか実行していないにもかかわらず、多くのプログラムが同時に実行されているように見えるかもしれません。マルチタスクのこの方法は、各プログラムに順番に時間の「スライス」が割り当てられるため、「タイムシェアリング」と呼ばれることもある。

安価なコンピュータの時代以前は、マルチタスクの主な用途は、多くの人が同じコンピュータを共有できるようにすることでした。一見、マルチタスクは、複数のプログラムを切り替えているコンピュータの動作を、実行しているプログラムの数に比例して遅くするように見えますが、ほとんどのプログラムは、タスクを完了するために、遅い入出力デバイスを待つことに多くの時間を費やしています。あるプログラムが、ユーザがマウスをクリックしたりキーボードのキーを押したりするのを待っている場合、そのプログラムは、待っているイベントが発生するまで「タイムスライス」を取りません。これにより、他のプログラムの実行時間が解放されるため、多くのプログラムを許容できないほどの速度低下なしに同時に実行することができます。



## マルチプロセッシング

一部のコンピュータでは、マルチプロセッシング構成で複数のCPUに作業を分散させるように設計されており、かつてはスーパーコンピュータやメインフレームコンピュータ、サーバーなどの大型で強力なマシンにのみ採用されていた技術です。マルチプロセッサやマルチコア（1つの集積回路上に複数のCPUを搭載）のパーソナルコンピュータやノートパソコンは、現在では広く普及しており、その結果、低価格帯の市場での利用が増えています。

特にスーパーコンピュータは、基本的なストアドプログラムアーキテクチャや汎用コンピュータとは大きく異なる非常にユニークなアーキテクチャを持つことが多く 、数千個のCPU、カスタマイズされた高速相互接続、および特殊なコンピューティングハードウェアを特徴とすることがよくあります。このような設計は、利用可能なリソースのほとんどを一度にうまく利用するために必要な大規模なプログラム編成のため、特殊なタスクにのみ有用である傾向があります。スーパーコンピュータは通常、大規模シミュレーション、グラフィックスレンダリング、暗号化アプリケーション、および他のいわゆる「恥ずかしいほど並列」なタスクで使用されています。



# ソフトウェア

ソフトウェアとは、プログラム、データ、プロトコルなど、コンピュータの中で物質的な形を持たない部分を指します。ソフトウェアとは、システムが構築される物理的なハードウェアとは対照的に、符号化された情報やコンピュータ命令で構成されるコンピュータシステムの部分を指す。コンピュータソフトウェアには、コンピュータプログラム、ライブラリ、およびオンラインドキュメントやデジタルメディアなどの実行不可能な関連データが含まれます。コンピュータ・ハードウェアとソフトウェアは互いに必要とし、どちらも単独では現実的に使用できません。IBM PC互換コンピュータのBIOS ROMのように、ソフトウェアが簡単に変更できないハードウェアに格納されている場合は、「ファームウェア」と呼ばれることがあります。



| [Operating system](https://en.wikipedia.org/wiki/Operating_system) /System Software | [Unix](https://en.wikipedia.org/wiki/Unix) and [BSD](https://en.wikipedia.org/wiki/Berkeley_Software_Distribution) | [UNIX System V](https://en.wikipedia.org/wiki/UNIX_System_V), [IBM AIX](https://en.wikipedia.org/wiki/IBM_AIX), [HP-UX](https://en.wikipedia.org/wiki/HP-UX), [Solaris](https://en.wikipedia.org/wiki/Solaris_(operating_system)) ([SunOS](https://en.wikipedia.org/wiki/SunOS)), [IRIX](https://en.wikipedia.org/wiki/IRIX), [List of BSD operating systems](https://en.wikipedia.org/wiki/List_of_BSD_operating_systems) |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| [GNU](https://en.wikipedia.org/wiki/GNU)/[Linux](https://en.wikipedia.org/wiki/Linux) | [List of Linux distributions](https://en.wikipedia.org/wiki/List_of_Linux_distributions), [Comparison of Linux distributions](https://en.wikipedia.org/wiki/Comparison_of_Linux_distributions) |                                                              |
| [Microsoft Windows](https://en.wikipedia.org/wiki/Microsoft_Windows) | [Windows (https://en.wikipedia.org/wiki/Windows_95), [Windows (https://en.wikipedia.org/wiki/Windows_98), [Windows NT](https://en.wikipedia.org/wiki/Windows_NT), [Windows (https://en.wikipedia.org/wiki/Windows_2000), [Windows ME](https://en.wikipedia.org/wiki/Windows_ME), [Windows XP](https://en.wikipedia.org/wiki/Windows_XP), [Windows Vista](https://en.wikipedia.org/wiki/Windows_Vista), [Windows (https://en.wikipedia.org/wiki/Windows_7), [Windows (https://en.wikipedia.org/wiki/Windows_8), [Windows 8.(https://en.wikipedia.org/wiki/Windows_8.1), [Windows (https://en.wikipedia.org/wiki/Windows_10) |                                                              |
| [DOS](https://en.wikipedia.org/wiki/DOS)                     | [86-DOS](https://en.wikipedia.org/wiki/86-DOS) (QDOS), [IBM PC DOS](https://en.wikipedia.org/wiki/IBM_PC_DOS), [MS-DOS](https://en.wikipedia.org/wiki/MS-DOS), [DR-DOS](https://en.wikipedia.org/wiki/DR-DOS), [FreeDOS](https://en.wikipedia.org/wiki/FreeDOS) |                                                              |
| [Macintosh operating systems](https://en.wikipedia.org/wiki/Macintosh_operating_systems) | [Classic Mac OS](https://en.wikipedia.org/wiki/Classic_Mac_OS), [macOS](https://en.wikipedia.org/wiki/MacOS) (previously OS X and Mac OS X) |                                                              |
| [Embedded](https://en.wikipedia.org/wiki/Embedded_operating_system) and [real-time](https://en.wikipedia.org/wiki/Real-time_operating_system) | [List of embedded operating systems](https://en.wikipedia.org/wiki/List_of_operating_systems#Embedded) |                                                              |
| Experimental                                                 | [Amoeba](https://en.wikipedia.org/wiki/Amoeba_(operating_system)), [Oberon](https://en.wikipedia.org/wiki/Oberon_(operating_system))/[Bluebottle](https://en.wikipedia.org/wiki/Bluebottle_OS), [Plan 9 from Bell Labs](https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs) |                                                              |
| [Library](https://en.wikipedia.org/wiki/Library_(computing)) | [Multimedia](https://en.wikipedia.org/wiki/Multimedia)       | [DirectX](https://en.wikipedia.org/wiki/DirectX), [OpenGL](https://en.wikipedia.org/wiki/OpenGL), [OpenAL](https://en.wikipedia.org/wiki/OpenAL), [Vulkan (API)](https://en.wikipedia.org/wiki/Vulkan_(API)) |
| Programming library                                          | [C standard library](https://en.wikipedia.org/wiki/C_standard_library), [Standard Template Library](https://en.wikipedia.org/wiki/Standard_Template_Library) |                                                              |
| [Data](https://en.wikipedia.org/wiki/Data_(computing))       | [Protocol](https://en.wikipedia.org/wiki/Protocol_(computing)) | [TCP/IP](https://en.wikipedia.org/wiki/Internet_protocol_suite), [Kermit](https://en.wikipedia.org/wiki/Kermit_(protocol)), [FTP](https://en.wikipedia.org/wiki/File_Transfer_Protocol), [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol), [SMTP](https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol) |
| [File format](https://en.wikipedia.org/wiki/File_format)     | [HTML](https://en.wikipedia.org/wiki/HTML), [XML](https://en.wikipedia.org/wiki/XML), [JPEG](https://en.wikipedia.org/wiki/JPEG), [MPEG](https://en.wikipedia.org/wiki/Moving_Picture_Experts_Group), [PNG](https://en.wikipedia.org/wiki/Portable_Network_Graphics) |                                                              |
| [User interface](https://en.wikipedia.org/wiki/User_interface) | [Graphical user interface](https://en.wikipedia.org/wiki/Graphical_user_interface) ([WIMP](https://en.wikipedia.org/wiki/WIMP_(computing))) | [Microsoft Windows](https://en.wikipedia.org/wiki/Microsoft_Windows), [GNOME](https://en.wikipedia.org/wiki/GNOME), [KDE](https://en.wikipedia.org/wiki/KDE), [QNX](https://en.wikipedia.org/wiki/QNX) Photon, [CDE](https://en.wikipedia.org/wiki/Common_Desktop_Environment), [GEM](https://en.wikipedia.org/wiki/Graphics_Environment_Manager), [Aqua](https://en.wikipedia.org/wiki/Aqua_(user_interface)) |
| [Text-based user interface](https://en.wikipedia.org/wiki/Text-based_(computing)) | [Command-line interface](https://en.wikipedia.org/wiki/Command-line_interface), [Text user interface](https://en.wikipedia.org/wiki/Text_user_interface) |                                                              |
| [Application](https://en.wikipedia.org/wiki/Application_software) Software | [Office suite](https://en.wikipedia.org/wiki/Office_suite)   | [Word processing](https://en.wikipedia.org/wiki/Word_processing), [Desktop publishing](https://en.wikipedia.org/wiki/Desktop_publishing), [Presentation program](https://en.wikipedia.org/wiki/Presentation_program), [Database management system](https://en.wikipedia.org/wiki/Database_management_system), Scheduling & Time management, [Spreadsheet](https://en.wikipedia.org/wiki/Spreadsheet), [Accounting software](https://en.wikipedia.org/wiki/Accounting_software) |
| Internet Access                                              | [Browser](https://en.wikipedia.org/wiki/Web_browser), [Email client](https://en.wikipedia.org/wiki/Email_client), [Web server](https://en.wikipedia.org/wiki/Web_server), [Mail transfer agent](https://en.wikipedia.org/wiki/Mail_transfer_agent), [Instant messaging](https://en.wikipedia.org/wiki/Instant_messaging) |                                                              |
| Design and manufacturing                                     | [Computer-aided design](https://en.wikipedia.org/wiki/Computer-aided_design), [Computer-aided manufacturing](https://en.wikipedia.org/wiki/Computer-aided_manufacturing), Plant management, Robotic manufacturing, Supply chain management |                                                              |
| [Graphics](https://en.wikipedia.org/wiki/Computer_graphics)  | [Raster graphics editor](https://en.wikipedia.org/wiki/Raster_graphics_editor), [Vector graphics editor](https://en.wikipedia.org/wiki/Vector_graphics_editor), [3D modeler](https://en.wikipedia.org/wiki/3D_computer_graphics_software), [Animation editor](https://en.wikipedia.org/wiki/Computer_animation), [3D computer graphics](https://en.wikipedia.org/wiki/3D_computer_graphics), [Video editing](https://en.wikipedia.org/wiki/Video_editing), [Image processing](https://en.wikipedia.org/wiki/Image_processing) |                                                              |
| [Audio](https://en.wikipedia.org/wiki/Digital_audio)         | [Digital audio editor](https://en.wikipedia.org/wiki/Digital_audio_editor), [Audio playback](https://en.wikipedia.org/wiki/Audio_player_(software)), [Mixing](https://en.wikipedia.org/wiki/Audio_mixing), [Audio synthesis](https://en.wikipedia.org/wiki/Software_synthesizer), [Computer music](https://en.wikipedia.org/wiki/Computer_music) |                                                              |
| [Software engineering](https://en.wikipedia.org/wiki/Software_engineering) | [Compiler](https://en.wikipedia.org/wiki/Compiler), [Assembler](https://en.wikipedia.org/wiki/Assembler_(computer_programming)), [Interpreter](https://en.wikipedia.org/wiki/Interpreter_(computing)), [Debugger](https://en.wikipedia.org/wiki/Debugger), [Text editor](https://en.wikipedia.org/wiki/Text_editor), [Integrated development environment](https://en.wikipedia.org/wiki/Integrated_development_environment), [Software performance analysis](https://en.wikipedia.org/wiki/Software_performance_analysis), [Revision control](https://en.wikipedia.org/wiki/Revision_control), [Software configuration management](https://en.wikipedia.org/wiki/Software_configuration_management) |                                                              |
| Educational                                                  | [Edutainment](https://en.wikipedia.org/wiki/Edutainment), [Educational game](https://en.wikipedia.org/wiki/Educational_game), [Serious game](https://en.wikipedia.org/wiki/Serious_game), [Flight simulator](https://en.wikipedia.org/wiki/Flight_simulator) |                                                              |
| [Games](https://en.wikipedia.org/wiki/Video_game)            | [Strategy](https://en.wikipedia.org/wiki/Strategy_game), [Arcade](https://en.wikipedia.org/wiki/Arcade_game), [Puzzle](https://en.wikipedia.org/wiki/Puzzle_video_game), [Simulation](https://en.wikipedia.org/wiki/Simulation_video_game), [First-person shooter](https://en.wikipedia.org/wiki/First-person_shooter), [Platform](https://en.wikipedia.org/wiki/Platform_game), [Massively multiplayer](https://en.wikipedia.org/wiki/Massively_multiplayer_online_game), [Interactive fiction](https://en.wikipedia.org/wiki/Interactive_fiction) |                                                              |
| Misc                                                         | [Artificial intelligence](https://en.wikipedia.org/wiki/Artificial_intelligence), [Antivirus software](https://en.wikipedia.org/wiki/Antivirus_software), [Malware scanner](https://en.wikipedia.org/wiki/Malware_scanner), [Installer](https://en.wikipedia.org/wiki/Installation_(computer_programs))/[Package management systems](https://en.wikipedia.org/wiki/Package_management_system), [File manager](https://en.wikipedia.org/wiki/File_manager) |                                                              |



## プログラミング言語

プログラミング言語には数千種類もの言語があり、中には汎用性を目的としたものもあれば、高度に専門化されたアプリケーションにのみ有用なものもあります。

| Lists of programming languages                               | [Timeline of programming languages](https://en.wikipedia.org/wiki/Timeline_of_programming_languages), [List of programming languages by category](https://en.wikipedia.org/wiki/List_of_programming_languages_by_category), [Generational list of programming languages](https://en.wikipedia.org/wiki/Generational_list_of_programming_languages), [List of programming languages](https://en.wikipedia.org/wiki/List_of_programming_languages), [Non-English-based programming languages](https://en.wikipedia.org/wiki/Non-English-based_programming_languages) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Commonly used [assembly languages](https://en.wikipedia.org/wiki/Assembly_language) | [ARM](https://en.wikipedia.org/wiki/ARM_architecture), [MIPS](https://en.wikipedia.org/wiki/MIPS_architecture), [x(https://en.wikipedia.org/wiki/X86_assembly_language) |
| Commonly used [high-level programming languages](https://en.wikipedia.org/wiki/High-level_programming_language) | [Ada](https://en.wikipedia.org/wiki/Ada_(programming_language)), [BASIC](https://en.wikipedia.org/wiki/BASIC), [C](https://en.wikipedia.org/wiki/C_(programming_language)), [C++](https://en.wikipedia.org/wiki/C%2B%2B), [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language)), [COBOL](https://en.wikipedia.org/wiki/COBOL), [Fortran](https://en.wikipedia.org/wiki/Fortran), [PL/I](https://en.wikipedia.org/wiki/PL/I), [REXX](https://en.wikipedia.org/wiki/REXX), [Java](https://en.wikipedia.org/wiki/Java_(programming_language)), [Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language)), [Pascal](https://en.wikipedia.org/wiki/Pascal_(programming_language)), [Object Pascal](https://en.wikipedia.org/wiki/Object_Pascal) |
| Commonly used [scripting languages](https://en.wikipedia.org/wiki/Scripting_language) | [Bourne script](https://en.wikipedia.org/wiki/Bourne_shell), [JavaScript](https://en.wikipedia.org/wiki/JavaScript), [Python](https://en.wikipedia.org/wiki/Python_(programming_language)), [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language)), [PHP](https://en.wikipedia.org/wiki/PHP), [Perl](https://en.wikipedia.org/wiki/Perl) |



## プログラム

他のすべての機械と区別する現代のコンピュータの特徴は、プログラムすることができるということです。つまり、ある種の命令(プログラム)をコンピュータに与えれば、それを処理することができるということです。フォン・ノイマン・アーキテクチャに基づく現代のコンピュータは、多くの場合、命令型プログラミング言語の形で機械コードを持っています。実用的には、コンピュータのプログラムは、例えばワープロやウェブブラウザのプログラムのように、ほんの数個の命令であったり、何百万もの命令に拡張されたりすることがあります。典型的な現代のコンピュータは毎秒数十億の命令を実行することができ（ギガフロップス）、長年の運用でミスをすることはほとんどありません。数百万の命令で構成される大規模なコンピュータプログラムは、プログラマーのチームが書くのに何年もかかることがあり、その作業の複雑さのために、ほとんどの場合間違いなくエラーが含まれています。



### ストアドプログラムのアーキテクチャ

ここでは、ほとんどの一般的なRAMマシンベースのコンピュータに適用されます。

ほとんどの場合、コンピュータの命令は単純なものです。これらの命令はコンピュータのメモリから読み出され、一般的には与えられた順番で実行（実行）されます。しかし、通常、プログラムのどこか別の場所に先にジャンプしたり、後ろにジャンプしたりして、そこから実行を続けるようにコンピュータに指示するための特殊な命令があります。これらは「ジャンプ」命令（または分岐）と呼ばれています。さらに、ジャンプ命令は条件付きで実行されることもあり、以前の計算結果や外部イベントの結果に応じて、異なる命令のシーケンスが使用されることもあります。多くのコンピュータでは、ジャンプした場所を「記憶」するタイプのジャンプ命令と、そのジャンプ命令に続く命令に戻る別の命令を提供することで、サブルーチンを直接サポートしています。

プログラムの実行は、本を読むことに例えられるかもしれません。人は通常、各単語や行を順番に読んでいきますが、時にはテキストの中の以前の場所にジャンプして戻ったり、興味のない部分を飛ばしたりすることがあります。同様に、コンピュータは、ある内部条件が満たされるまで、プログラムのいくつかのセクションの指示を何度も何度も戻って繰り返すことがあります。これはプログラム内の制御の流れと呼ばれ、人間の介入なしにコンピュータが繰り返しタスクを実行することを可能にするものです。

比較的、ポケット電卓を使っている人は、2つの数字の足し算などの基本的な算術操作をボタンを数回押すだけで行うことができます。しかし、1から1,000までのすべての数字を足し合わせるには、何千回もボタンを押す必要があり、多くの時間がかかり、ほぼ確実に間違いを犯すことになります。一方、コンピュータは、ほんの数回の簡単な命令でこのようなことができるようにプログラムされているかもしれません。次の例は、MIPSアセンブリ言語で書かれています。



```assembly
  begin:
  addi $8, $0, 0           # initialize sum to 0
  addi $9, $0, 1           # set first number to add = 1
  loop:
  slti $10, $9, 1000       # check if the number is less than 1000
  beq $10, $0, finish      # if odd number is greater than n then exit
  add $8, $8, $9           # update sum
  addi $9, $9, 1           # get next number
  j loop                   # repeat the summing process
  finish:
  add $2, $8, $0           # put sum in output register
```



このプログラムを実行するように指示されると、コンピュータはそれ以上の人間の介入なしに反復的な足し算タスクを実行します。ミスをすることはほとんどなく、現代のPCはあっという間にタスクを完了させることができます。



### 機械コード

ほとんどのコンピュータでは、個々の命令はマシンコードとして保存されており、各命令には固有の番号（操作コードまたは略してオペコード）が与えられています。2 つの数字を足し算する命令には 1 つのオペコードが、2 つの数字を乗算する命令には別のオペコードが与えられます。最も単純なコンピュータは一握りの異なる命令のいずれかを実行することができますが、より複雑なコンピュータは数百の命令から選択することができ、それぞれが固有の数値コードを持っています。コンピュータのメモリには数字を記憶することができるので、命令コードも記憶することができます。このことは、プログラム全体（これらの命令のリストにすぎない）を数字のリストとして表現することができ、それ自体が数値データと同じようにコンピュータ内部で操作できるという重要な事実につながります。プログラムを操作するデータと一緒にコンピュータのメモリに格納するという基本的な概念が、フォン・ノイマン、つまり格納プログラム[引用が必要]アーキテクチャの核心です。場合によっては、コンピュータが動作するデータとは別に、プログラムの一部または全部をメモリに格納することもあります。これは、ハーバード・マークIコンピュータにちなんでハーバード・アーキテクチャと呼ばれています。現代のフォン・ノイマン・コンピュータは、CPUキャッシュなどの設計においてハーバード・アーキテクチャの特徴をいくつか示しています。

コンピュータプログラムを長い数字のリスト（機械語）として記述することは可能であり、この技術は初期の多くのコンピュータで使用されていましたが、実際にそうすることは非常に面倒であり、特に複雑なプログラムの場合にはエラーを起こす可能性があります。その代わりに、各基本命令には、その機能を示し、覚えやすい短い名前、例えばADD、SUB、MULT、JUMPなどのニーモニックを付けることができます。これらのニーモニックは、総称してコンピュータのアセンブリ言語として知られています。アセンブリ言語で書かれたプログラムをコンピュータが実際に理解できるもの (機械語) に変換することは、通常、アセンブラと呼ばれるコンピュータ プログラムによって行われます。



### プログラミング言語

プログラミング言語は、コンピュータが実行するプログラムを指定するための様々な方法を提供しています。自然言語とは異なり、プログラミング言語は曖昧さを許さず、簡潔であるように設計されています。プログラミング言語は純粋に書かれた言語であり、声に出して読むのは難しいことが多い。一般的には、実行前にコンパイラやアセンブラによってマシンコードに翻訳されるか、あるいは実行時にインタプリタによって直接翻訳されます。時々、プログラムはこの2つの技術のハイブリッドな方法で実行されます。

### 低レベル言語

機械語とそれを表現するアセンブリ言語（低レベルプログラミング言語と総称される）は、一般的に、コンピュータの中央処理装置（CPU）の特定のアーキテクチャに固有のものです。例えば、ARMアーキテクチャのCPU（スマートフォンや携帯型ビデオゲームに見られるようなもの）は、PCに搭載されている可能性のあるx86 CPUの機械語を理解することはできません。歴史的には、Zilog Z80に加えてMOS Technology 6502や6510など、かなりの数の他のCPUアーキテクチャが作成され、広範囲に使用されてきました。

### 高レベル言語

機械語に比べればかなり簡単ですが、アセンブリ言語で長いプログラムを書くことはしばしば困難であり、エラーが発生しやすいです。そのため、ほとんどの実用的なプログラムは、プログラマーのニーズをより便利に表現できる（それによってプログラマーのエラーを減らすのに役立つ）、より抽象的な高レベルプログラミング言語で書かれています。高レベル言語は通常、コンパイラと呼ばれる別のコンピュータプログラムを使用して機械語に「コンパイル」されます。したがって、同じ高レベル言語プログラムを多くの異なるタイプのコンピュータの機械語に翻訳するために、異なるコンパイラを使用することがしばしば可能である。これは、ビデオゲームのようなソフトウェアを、パーソナルコンピュータや様々なビデオゲーム機のような異なるコンピュータアーキテクチャで利用できるようにするための手段の一部です。

### プログラム設計

小さなプログラムのプログラム設計は比較的簡単で、問題の分析、入力の収集、言語内のプログラミング構成要素の使用、確立された手順とアルゴリズムの考案または使用、出力装置のためのデータの提供、および該当する場合には問題の解決策を含む。問題が大きく複雑になるにつれて、サブプログラム、モジュール、形式的なドキュメント、オブジェクト指向プログラミングのような新しいパラダイムなどの機能に遭遇します。数千行以上のコードを含む大規模なプログラムでは、正式なソフトウェアの方法論が必要となります。大規模なソフトウェアシステムを開発するというタスクは、重要な知的課題を提示します。予測可能なスケジュールと予算の範囲内で、信頼性の高いソフトウェアを生産することは、歴史的に困難なことでした。

### バグ

コンピュータプログラムのエラーは「バグ」と呼ばれます。これらのエラーは、プログラムの有用性に影響を与えない良性のものである場合もあれば、微妙な影響を与えるだけのものである場合もあります。しかし、場合によっては、プログラムやシステム全体を「ハングアップ」させたり、マウスクリックやキー入力などの入力に反応しなくなったり、完全に失敗したり、クラッシュしたりすることもあります。そうでなければ良性のバグであっても、不謹慎なユーザが悪意を持って悪用するコードを書いたり、バグを利用してコンピュータの正常な実行を妨害するように設計されたコードを書いたりすることで、悪意のある意図のためにバグを利用することがあります。バグは通常、コンピュータのせいではありません。コンピュータは単に与えられた命令を実行するだけなので、バグはほとんど常にプログラマのエラーやプログラムの設計上の見落としの結果である。 アメリカのコンピュータ科学者であり、最初のコンパイラの開発者であるグレース・ホッパー提督は、1947年9月にハーバード・マークIIコンピュータのリレーがショートしているのを死んだ蛾が発見された後、コンピュータで初めて「バグ」という言葉を使ったとされている。



# ネットワークとインターネット

コンピュータは1950年代から複数の場所間の情報調整に利用されてきた。米軍のSAGEシステムは、このようなシステムの最初の大規模な例であり、セイバーのような多くの特殊用途の商用システムにつながった。 1970年代になると、米国内の研究機関のコンピュータ技術者が、電気通信技術を使ってコンピュータを結びつける作業を始めた。この取り組みはARPA（現DARPA）の資金提供を受けて行われ、その結果生まれたコンピュータ・ネットワークはARPANETと呼ばれた。 Arpanetを可能にした技術は普及し、進化していった。

やがて、ネットワークは学術機関や軍事機関を超えて広がり、インターネットとして知られるようになった。ネットワークの出現は、コンピュータの性質と境界線の再定義をもたらした。コンピュータのオペレーティングシステムやアプリケーションは、個々のコンピュータのリソースの拡張として、ネットワーク上の他のコンピュータのリソース、例えば周辺機器、保存された情報などを定義し、アクセスする機能を含むように変更されました。当初、これらの機能は主にハイテク環境で働く人々が利用できましたが、1990年代には電子メールやワールド・ワイド・ウェブのようなアプリケーションの普及と、イーサネットやADSLのような安価で高速なネットワーク技術の開発が相まって、コンピュータ・ネットワーキングはほぼユビキタスなものになりました。実際、ネットワーク化されているコンピュータの数は驚異的に増加しています。非常に多くのパーソナル・コンピュータが、定期的にインターネットに接続して情報のやり取りや受信を行っています。"携帯電話ネットワークを利用することが多い「ワイヤレス」ネットワーキングは、モバイルコンピューティング環境でもネットワークがますますユビキタスになってきていることを意味しています。



# 型にはまらないコンピュータ

コンピュータは、電子的なものである必要はなく、プロセッサやRAM、ハードディスクである必要もない。コンピュータ」という言葉の一般的な使用法は、パーソナル電子コンピュータと同義であるが、現代のコンピュータの定義は文字通りのものである。"計算を行う装置、特に高速の数学的または論理的操作を実行する、または情報をアセンブル、保存、相関、またはその他の方法で処理するプログラム可能な（通常は）電子機械」 情報を処理するすべての装置は、特に処理が目的的である場合には、コンピュータとして適格である。



# 未来

光コンピュータ、DNAコンピュータ、ニューラルコンピュータ、量子コンピュータなど、多くの有望な新技術を用いてコンピュータを作る研究が盛んに行われています。ほとんどのコンピュータは普遍的なもので、あらゆる計算関数を計算することができ、メモリ容量と動作速度によって制限されています。例えば、量子コンピュータは（量子ファクタリングによって）現代の暗号化アルゴリズムを非常に速く破る可能性があります。

## コンピュータアーキテクチャのパラダイム

コンピュータのアーキテクチャにはいろいろな種類があります。

- 量子コンピュータと化学コンピュータ
- スカラープロセッサとベクタープロセッサの比較
- 非一様記憶アクセス（ＮＵＭＡ）計算機
- レジスタマシンとスタックマシン
- ハーバード建築対フォン・ノイマン建築

- 細胞構造

これらすべての抽象機械の中で、量子コンピュータはコンピューティングに革命を起こすことが最も期待されています。 ロジックゲートは、上記のデジタルまたはアナログパラダイムのほとんどに適用できる共通の抽象化です。プログラムと呼ばれる命令のリストを保存して実行する能力は、コンピュータを電卓と区別して、非常に汎用性の高いものにしています。チャーチ・チューリングのテーゼは、この汎用性を数学的に表現したものです：最低限の能力（チューリング完全であること）を持つどんなコンピュータでも、原則として、他のどんなコンピュータでも実行できるのと同じタスクを実行することができます。したがって、どのようなタイプのコンピュータ（ネットブック、スーパーコンピュータ、セル・オートマトンなど）でも、十分な時間と記憶容量があれば、同じ計算タスクを実行することができます。

## 人工知能

コンピュータは、効率性、代替ソリューション、可能なショートカット、またはコード内の可能性のあるエラーを考慮することなく、プログラムされた方法で正確に問題を解決します。学習して適応するコンピュータプログラムは、人工知能と機械学習の新興分野の一部です。人工知能ベースの製品は一般的に、ルールベースのシステムとパターン認識システムの2つの大きなカテゴリーに分類されます。ルールベースのシステムは、人間の専門家が使用するルールを表現しようとするもので、開発コストが高くなる傾向にあります。パターンベースのシステムは、問題に関するデータを使用して結論を導き出します。パターンベースのシステムの例としては、音声認識、フォント認識、翻訳、オンラインマーケティングの新興分野などがあります。