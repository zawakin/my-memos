# このページでまとめたアーキテクチャ一覧

- ppc64
- 386
- amd64
- arm
- arm64
- wasm
- mips
- mips64
- mips64le
- mipsle
- ppc64
- ppc64le
- riscv64
- s390x



# Instruction set architectureとは？

[Instruction_set_architecture(en.wikipedia)](https://en.wikipedia.org/wiki/Instruction_set_architecture)

命令セットアーキテクチャ（ISA）は、コンピュータの抽象モデルです。アーキテクチャやコンピュータアーキテクチャとも呼ばれます。中央処理装置（CPU）などのISAを実現したものを実装と呼びます。

一般的に、ISAは、サポートされるデータ型、レジスタ、メインメモリの基本機能（メモリの整合性、アドレッシングモード、仮想メモリなど）を管理するためのハードウェアサポート、およびISAの実装のファミリの入出力モデルを定義します。

ISAは、そのISAの実装上で実行されるマシンコードの動作を、その実装の特性に依存しない方法で指定し、実装間のバイナリ互換性を提供します。これにより、性能、物理的なサイズ、金銭的なコスト（特に）が異なるISAの複数のインプリメンテーションが可能になり、同じマシンコードを実行することが可能になり、低性能で低コストのマシンを、ソフトウェアを交換することなく、高コストで高パフォーマンスのマシンに置き換えることができます。また、ISAの実装のマイクロアーキテクチャを進化させることができ、ISAのより新しく高性能な実装では、前世代の実装で動作するソフトウェアを実行することができます。

オペレーティングシステムが特定のISAの標準的で互換性のあるアプリケーション・バイナリ・インターフェース（ABI）を維持している場合、そのISAとオペレーティングシステムのマシンコードは、そのISAの将来の実装とそのオペレーティングシステムの新しいバージョンで実行されます。しかし、ISA が複数のオペレーティングシステムの実行をサポートしている場合、最初のオペレーティングシステムが他のオペレーティングシステム用に構築されたマシンコードの実行をサポートしない限り、あるオペレーティングシステム用のマシンコードが他のオペレーティングシステム上で実行されることは保証されません。

ISAは、命令や他の機能を追加したり、より大きなアドレスやデータ値のサポートを追加することで拡張することができます。拡張されたISAの実装は、拡張されていないISAのバージョンのマシンコードを実行することができます。拡張されたISAの実装は、拡張されていないISAのバージョンのマシンコードを実行することができます。拡張されたISAを使用するマシンコードは、拡張されたISAをサポートする実装上でのみ実行されます。

これらの拡張機能が提供するバイナリ互換性により、ISA はコンピューティングにおける最も基本的な抽象化の一つとなっています。

## 概要

命令セット・アーキテクチャは、マイクロアーキテクチャとは区別され、マイクロアーキテクチャは、特定のプロセッサで命令セットを実装するために使用されるプロセッサ設計技術のセットです。異なるマイクロアーキテクチャを持つプロセッサは、共通の命令セットを共有することができます。例えば、Intel Pentium と Advanced Micro Devices Athlon は、ほぼ同じバージョンの x86 命令セットを実装していますが、内部設計は全く異なります。

特定のマシンの設計とは異なるアーキテクチャの概念は、IBMのフレッド・ブルックスがSystem/360の設計段階で開発したものです。
NPL [System/360]以前は、IBMのコンピュータ設計者は、技術を選択するだけでなく、機能やアーキテクチャを改良することで、自由にコスト目標を達成していました。対照的に、SPREAD互換性目標では、コストと性能の広い範囲に渡る5つのプロセッサのシリーズに対して、単一のアーキテクチャを想定していました。5つの技術設計チームのいずれも、コストと性能の目標達成の困難さを緩和する方法として、アーキテクチャの仕様を調整することができるかどうかはあてにならなかった[1]:p.137

Java 仮想マシンの Smalltalk や Microsoft の Common Language Runtime など、バイトコードを ISA としてサポートしているいくつかの仮想マシンでは、一般的に使用されるコードパスのバイトコードをネイティブマシンのコードに変換することでこれを実装しています。さらに、これらの仮想マシンは、あまり頻繁に使用されないコードパスを解釈して実行します（参照：ジャストインタイムコンパイル）。Transmeta は、VLIW プロセッサの上に x86 命令セットをこの方法で実装しました。



## ISAの分類

ISAは、いくつかの異なる方法で分類されることがあります。一般的な分類は、アーキテクチャの複雑さによるものです。複雑な命令セットコンピュータ(CISC)は、多くの特殊な命令を持ち、その中には実用的なプログラムではほとんど使用されない命令も含まれています。縮小命令セットコンピュータ(RISC)は、プログラムで頻繁に使用される命令のみを効率的に実装することでプロセッサを簡素化し、あまり一般的ではない操作はサブルーチンとして実装され、その結果として生じる追加のプロセッサ実行時間を使用頻度が低いことで相殺している[2]。

その他のタイプとしては、非常に長い命令語(VLIW)アーキテクチャや、密接に関連する長い命令語(LIW)アーキテクチャ、明示的並列命令コンピューティング(EPIC)アーキテクチャなどがあります。これらのアーキテクチャは、命令の発行とスケジューリングをコンパイラに任せることで、RISCやCISCよりも少ないハードウェアで命令レベルの並列性を利用しようとしています。

また、MISC(Minimal Instruction Set Computer)やOISC(One Instruction Set Computer)のように、さらに複雑さを抑えたアーキテクチャも研究されています。これらは理論的には重要なタイプであるが、実用化されていない。

# コンピュータ・アーキテクチャ

[コンピュータ・アーキテクチャ(ja.wikipedia.org)](https://ja.wikipedia.org/wiki/コンピュータ・アーキテクチャ)

## 命令セットアーキテクチャ

- RISC
- CISC
- VLIW
- EPICアーキテクチャ

（実装例）x86(IA-32)、PowerPC、SPARCなど。

## マイクロアーキテクチャ

- 演算アーキテクチャ
  [浮動小数点](https://ja.wikipedia.org/wiki/浮動小数点)、[演算装置](https://ja.wikipedia.org/wiki/演算装置)、[SIMD](https://ja.wikipedia.org/wiki/SIMD)/[MIMD](https://ja.wikipedia.org/wiki/MIMD)、[ベクトル演算](https://ja.wikipedia.org/wiki/ベクトル演算)ユニット([ベクトル計算機](https://ja.wikipedia.org/wiki/ベクトル計算機))
- CPU制御アーキテクチャ
  [ワイヤードロジック](https://ja.wikipedia.org/wiki/ワイヤードロジック)、[マイクロプログラム](https://ja.wikipedia.org/wiki/マイクロプログラム方式)（マイクロアーキテクチャ）、[実行ユニット](https://ja.wikipedia.org/wiki/実行ユニット)、[制御装置](https://ja.wikipedia.org/wiki/制御装置)
- CPU高速化アーキテクチャ
  [パイプライン](https://ja.wikipedia.org/wiki/命令パイプライン)、[スーパースケーラ](https://ja.wikipedia.org/wiki/スーパースケーラ)、[アウト・オブ・オーダー実行](https://ja.wikipedia.org/wiki/アウト・オブ・オーダー実行)、[分岐予測](https://ja.wikipedia.org/wiki/分岐予測)、[レジスタ・ウィンドウ](https://ja.wikipedia.org/wiki/レジスタ・ウィンドウ)、[レジスタ・リネーミング](https://ja.wikipedia.org/wiki/レジスタ・リネーミング)、[投機的実行](https://ja.wikipedia.org/wiki/投機的実行)
- CPUバスアーキテクチャ
  CPUバス（CPU内部バス、CPU外部バス《ピン》アーキテクチャ）、[バス (コンピュータ)](https://ja.wikipedia.org/wiki/バス_(コンピュータ))の項を参照。<スタブ>
- [マルチプロセッサ](https://ja.wikipedia.org/wiki/マルチプロセッサ)アーキテクチャ
  [対称型マルチプロセッサ](https://ja.wikipedia.org/wiki/対称型マルチプロセッサ)(SMP)、[NUMA](https://ja.wikipedia.org/wiki/NUMA)(ASMP)、[クロスバースイッチ](https://ja.wikipedia.org/wiki/クロスバースイッチ) <スタブ>
- [マルチスレッド](https://ja.wikipedia.org/wiki/ハードウェアマルチスレッディング)アーキテクチャ
  [ブロック型マルチスレッディング](https://ja.wikipedia.org/wiki/ハードウェアマルチスレッディング#ブロック型マルチスレッディング)、[インターリーブ型マルチスレッディング](https://ja.wikipedia.org/wiki/バレルプロセッサ)、[同時マルチスレッディング](https://ja.wikipedia.org/wiki/同時マルチスレッディング)

## システムアーキテクチャ

- 制御アーキテクチャ
  [割り込み](https://ja.wikipedia.org/wiki/割り込み_(コンピュータ))制御、[入出力](https://ja.wikipedia.org/wiki/入出力)制御

- バスアーキテクチャ

  ハーバードアーキテクチャ

  、プログラム内蔵方式（

  ノイマン型

  を含む）

  クロスバースイッチ

  システムバス、メモリバス、入出力バス。

  バス (コンピュータ)

  の項を参照。<スタブ>

  - （実装例）ISA、PCI等の[拡張バス](https://ja.wikipedia.org/wiki/拡張バス)アーキテクチャ。

- メモリアーキテクチャ
  [キャッシュメモリ](https://ja.wikipedia.org/wiki/キャッシュメモリ)、[仮想記憶](https://ja.wikipedia.org/wiki/仮想記憶)、[TLB](https://ja.wikipedia.org/wiki/トランスレーション・ルックアサイド・バッファ)　<スタブ> -- [メモリ](https://ja.wikipedia.org/wiki/メモリ)

- ネットワークアーキテクチャ
  <スタブ> -- [コンピュータネットワーク](https://ja.wikipedia.org/wiki/コンピュータネットワーク)

- [オペレーティングシステム](https://ja.wikipedia.org/wiki/オペレーティングシステム)アーキテクチャ
  [ページング方式](https://ja.wikipedia.org/wiki/ページング方式)アーキテクチャ。<スタブ>

- [分散処理アーキテクチャー](https://ja.wikipedia.org/wiki/分散処理アーキテクチャー)



![img](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d8/ABasicComputer.gif/481px-ABasicComputer.gif)



## von Neumann architecture

[Von_Neumann_architecture(en.wikipedia)](https://en.wikipedia.org/wiki/Von_Neumann_architecture)

フォン・ノイマン・アーキテクチャ（フォン・ノイマン・モデル、プリンストン・アーキテクチャとも呼ばれる）は、ハンガリー系アメリカ人の数学者で物理学者のジョン・フォン・ノイマンらが1945年に発表した「EDVACに関する報告書の第1次草案」に基づいたコンピュータ・アーキテクチャです。この文書では、これらの構成要素を持つ電子デジタルコンピュータの設計アーキテクチャが記述されています。

- 算術論理ユニットとプロセッサレジスタを含む処理ユニット
- 命令レジスタとプログラムカウンタを内蔵した制御装置
- データや命令を記憶するメモリ
- 外部マスストレージ
- 入出力機構

「フォン・ノイマン・アーキテクチャ」という用語は、共通のバスを共有しているため、命令のフェッチとデータ操作が同時に発生しないストアド・プログラム・コンピュータを意味するように発展してきました。これは、フォン・ノイマン・ボトルネックと呼ばれ、しばしばシステムの性能を制限します。

フォン・ノイマン・アーキテクチャー・マシンの設計は、ハーバード・アーキテクチャー・マシン（ストアド・プログラム・システムでもあるが、メモリへの読み書きのための専用のアドレス・データ・バスと、命令を取得するための別のアドレス・データ・バスのセットを持つ）よりも単純である。

ストアド・プログラム・デジタル・コンピュータは、プログラム命令とデータの両方を読み書き可能なランダム・アクセス・メモリ（RAM）に保存します。ストアドプログラムコンピュータは、1940年代のコロッサスやENIACなどのプログラム制御型コンピュータよりも進歩したものです。これらのコンピュータは、様々な機能ユニット間でデータや制御信号をルーティングするために、スイッチを設定したり、パッチケーブルを挿入したりすることでプログラムされていました。現代のコンピュータの大部分は、データとプログラム命令の両方に同じメモリを使用しています。フォン・ノイマンとハーバードの区別は、メインメモリ（分割キャッシュアーキテクチャ）ではなく、キャッシュアーキテクチャに適用されます。



### 歴史

初期のコンピュータは固定プログラムを持っていました。非常にシンプルなコンピュータの中には、今でもシンプルさやトレーニング目的のためにこの設計を採用しているものもあります。例えば、机上電卓は（原理的には）固定プログラムコンピュータです。基本的な数学はできますが、ワープロやゲームはできません。固定プログラムのマシンのプログラムを変更するには、マシンの再配線、再構築、再設計が必要です。初期のコンピュータは、特定のタスクのために「設計された」というほど「プログラムされた」ものではありませんでした。"再プログラム "は、可能な場合には、フローチャートや紙のメモから始まり、詳細なエンジニアリング設計、そして物理的にマシンを再配線して再構築するという手間のかかるプロセスを経て行われていました。ENIAC上でのプログラムのセットアップとデバッグには3週間かかることもありました。

ストアドプログラムコンピュータの提案で、これは変わりました。ストアドプログラムコンピュータは、設計上、命令セットを含み、計算を詳述する命令セット（プログラム）をメモリに格納することができる。

また、ストアドプログラム設計では、コードを自己修正することも可能です。このような機能の初期の動機の1つは、初期の設計では演算子が手動で行わなければならなかった命令のアドレス部分のインクリメントや修正をプログラムで行う必要があったことです。インデックスレジスタや間接アドレッシングがマシンアーキテクチャの通常の機能になってからは、この機能の重要性は低くなりました。もう一つの用途は、即時アドレッシングを使用して命令ストリームに頻繁に使用されるデータを埋め込むことでした。自己修正コードは通常、理解やデバッグが難しく、現代のプロセッサのパイプライン化やキャッシングスキームでは非効率的であるため、現在ではほとんどの場合、好まれなくなっています。



### 機能

大規模では、命令をデータとして扱うことができるからこそ、アセンブラ、コンパイラ、リンカ、ローダなどの自動化プログラミングツールが可能になる。プログラムを書くプログラム」を可能にしているのです。これにより、フォン・ノイマン・アーキテクチャのマシンを中心に、洗練されたセルフホスティング・コンピューティングのエコシステムが花開いている。

いくつかの高レベル言語は、実行時に実行コードを操作するための抽象的でマシンに依存しない方法を提供したり（LISPなど）、実行時の情報を利用してジャストインタイムのコンパイルを調整したりすることで、フォン・ノイマン・アーキテクチャを活用しています（Java仮想マシン上でホストされている言語や、Webブラウザに組み込まれている言語など）。

より小さな規模では、BITBLTやピクセルシェーダや頂点シェーダのようないくつかの反復的な操作は、汎用プロセッサ上でジャストインタイムコンパイル技術を用いて高速化することができます。これは、人気のある自己修正コードの1つの用途です。



### Development of the stored-program concept

ケンブリッジ大学のマックス・ニューマンの講義によって数学的論理学の問題に警鐘を鳴らした数学者アラン・チューリングは、1936年に「On Computable Numbers, with an Application to the Entscheidungsproblem」と題する論文を書き、ロンドン数学会の議事録に掲載されました。その中で彼は、現在「ユニバーサル・チューリング・マシン」として知られているユニバーサル・コンピューティング・マシンと呼ばれる仮想マシンについて述べています。この仮想マシンは、命令とデータの両方を含む無限のストア（今日の用語ではメモリ）を持っていた。ジョン・フォン・ノイマンがチューリングと知り合ったのは、1935年にケンブリッジ大学の客員教授をしていた時、また1936年から1937年にかけてニュージャージー州プリンストンの高等研究所でチューリングの博士号を取得していた時でした。その時にチューリングの1936年の論文を知っていたかどうかは明らかではありません。

1936年には、コンラッド・ズースも2つの特許出願で、機械の命令がデータに使われているのと同じストレージに格納されることを予想していた。

独立して、ペンシルバニア大学のムーア電気工学部でENIACを開発していたJ Presper EckertとJohn Mauchlyは、1943年12月にストアドプログラムの概念について書いています。エッカートは新機械EDVACを計画するにあたり、1944年1月に、新しいアドレス可能な記憶装置である水銀金属遅延線メモリにデータとプログラムを格納すると書いている。これが、実用的なストアドプログラムマシンの建設が提案された初めてのことであった。この時、彼とモーチュリーはチューリングの研究を知らなかった。

フォン・ノイマンはロスアラモス国立研究所のマンハッタン計画に関わっていたが、この計画では膨大な計算が必要であった。これが、1944年の夏、彼をENIACプロジェクトに引き寄せました。そこで彼は、この保存プログラムコンピュータEDVACの設計に関する継続的な議論に参加しました。このグループの一員として、彼はEckertとMauchlyの研究に基づいたEDVACに関する報告書の第一稿というタイトルの記述を書き上げた。彼の同僚のハーマン・ゴールドスタインがフォン・ノイマンの名前だけを載せてそれを回覧したときには未完成でしたが、エッカートとモーチュリーは大騒ぎになりました。この論文はアメリカとヨーロッパの何十人ものフォン・ノイマンの同僚に読まれ、次のコンピュータ設計に影響を与えました。



ジャック・コープランドは、「電子的に記憶されたプログラムのデジタル・コンピュータを「フォン・ノイマン・マシン」と呼ぶことは、歴史的に不適切である」と考えています。

 彼のロスアラモスの同僚であるスタン・フランケルは、フォン・ノイマンがチューリングのアイデアを尊重していたことについて次のように述べています。

私は、1943年か44年頃にフォン・ノイマンが1936年のチューリングの論文の根本的な重要性を十分に認識していたことを知っています...フォン・ノイマンは私にその論文を紹介してくれました。多くの人がフォン・ノイマンを「コンピュータの父」(現代的な意味での)と称賛していますが、私は彼自身がそのような過ちを犯すことはなかったと確信しています。彼は助産師と呼ばれているかもしれませんが、私や他の人たちには、基本的な概念はバベッジが予想していなかった限りにおいてチューリングによるものであることをしっかりと強調していました...もちろんチューリングとフォン・ノイマンは、これらの概念の「実践への還元」にもかなりの貢献をしましたが、私はこれらを、活動のプログラムをメモリに保存し、活動の過程でそのプログラムを修正することができるコンピュータの概念の導入と説明に匹敵する重要性とは考えていません。

第一草案」報告書が配布された当時、チューリングは「提案された電子計算機」と題する報告書を作成していました。それには、自動計算エンジン(ACE)と呼ばれる機械のアイデアが工学的にもプログラミング的にも詳細に記述されていました。彼はこれを1946年2月19日に英国国立物理研究所の執行委員会に提出しました。チューリングは戦時中のブレッチリー・パークでの経験から、彼が提案したものが実現可能であることを知っていましたが、その後数十年間維持されたコロッサスを取り巻く秘密が、彼がそう言うことを妨げていました。ACE設計の様々な成功した実装が生産されました。

フォン・ノイマンとチューリングの論文は両方とも保存プログラムコンピュータを記述していますが、フォン・ノイマンの初期の論文の方がより多くの流通を達成し、それが説明したコンピュータアーキテクチャは「フォン・ノイマン・アーキテクチャ」として知られるようになりました。1953年の出版物『Faster than Thought. A Symposium on Digital Computing Machines (Edit by B. V. Bowden)では、アメリカのコンピュータの章の一節は次のように書かれています。

**プリンストン高等研究所の機械**

>  1945年、E.N.I.A.C.が建設されたフィラデルフィアのムーア工科大学で働いていたJ.フォン・ノイマン教授は、同僚のグループを代表してデジタルコンピュータの論理設計に関する報告書を発表しました。その報告書には、後にE.D.V.A.C.（電子離散可変自動計算機）として知られるようになった機械の設計に関する詳細な提案が含まれていました。この機械はアメリカでは最近完成したばかりですが、フォン・ノイマンの報告書に触発されてケンブリッジにE.D.S.A.C.（電子遅延記憶式自動計算機）が建設されました（130ページ参照）。

> 1947年、バークス、ゴールドスタイン、フォン・ノイマンは、別のタイプの機械（今回は並列計算機）の設計の概要をまとめた報告書を発表しました。彼らは、そのようなマシンを構築する上での顕著な問題は、瞬時にアクセスできる内容を持つ適切なメモリの開発であると指摘した。最初に彼らが提案したのは、RCAのプリンストン研究所が発明した「セレクトロン」と呼ばれる特殊な真空管を使うことだった。この真空管は高価で作るのが難しかったため、フォン・ノイマンはその後、ウィリアムズのメモリをベースにした機械を作ることにした。この機械は1952年6月にプリンストンで完成し、「マニアック」として広く知られるようになりました。この機械のデザインは、現在アメリカで製造されている少なくとも6台の機械にインスピレーションを与え、「ジョニアック」という愛称で親しまれています。

同じ本の中で、ACEの章の最初の2段落は次のように読まれています。

**国立物理学研究所における自動計算**

> 自動電子計算技術の開発と改良を具現化した最も近代的なデジタルコンピュータの一つが、最近、国立物理研究所のテッディングトンで実演されました。これまでのところ研究所に設置されている装置は、自動計算エンジンとして知られているもっと大きな装置のパイロットモデルに過ぎませんが、プレートXII、XIII、XIVから判断できるように、比較的小型で、約800個の熱電対を含むだけですが、非常に高速で汎用性の高い計算機であることがわかります。

>  機械による計算の基本的な概念と抽象的な原理は、A.M.チューリング博士（F.R.S.）によって、1936年にロンドン数学会の前で読まれた論文1.で定式化されましたが、イギリスでのそのような機械の研究は戦争のために遅れていました。しかし、1945年に、問題の調査は、国立物理研究所で、当時研究所の数学部門の最高責任者であったJ.R.ウォーマスリー氏によって行われました。彼にはチューリング博士と少数の専門家スタッフが加わり、1947年までには予備的な計画が十分に進み、先に述べた特別なグループの設立を正当化することができました。1948年4月、後者はF.M.コールブルック氏の指揮の下、研究所の電子部門となりました。



### 進化

1960 年代から 1970 年代にかけて、コンピュータは一般的に小型化と高速化の両方を実現し、アーキテクチャの進化につながりました。例えば、メモリマップされたI/Oでは、入力デバイスと出力デバイスをメモリと同じように扱うことができます。単一のシステムバスを使用することで、低コストでモジュラーシステムを提供することができました[解明が必要]。これは、アーキテクチャの「合理化」と呼ばれることもあります。その後の数十年で、単純なマイクロコントローラは、コストとサイズを下げるためにモデルの機能を省略することもあった。より大きなコンピュータでは、高性能化のために機能が追加された。



### フォンノイマンボトルネック

プログラムメモリとデータメモリの間の共有バスは、中央処理装置（CPU）とメモリの間のスループット（データ転送レート）がメモリの量に比べて制限されるという、フォン・ノイマン・ボトルネックにつながる。単一バスは、一度に2つのクラスのメモリのうちの1つにしかアクセスできないため、スループットは、CPUが作業できる速度よりも低くなります。これは、CPUが大量のデータに対して最小限の処理を行う必要がある場合の実効処理速度を著しく制限します。ＣＰＵは、必要なデータがメモリに移動したり、メモリから移動したりするのを絶えず待たなければならない。CPUの速度とメモリサイズは、それらの間のスループットよりもはるかに速くなっているため、ボトルネックは、新世代のCPUが登場するたびに深刻さを増していく問題となっています。

フォン・ノイマンのボトルネックは、ジョン・バックウスが1977年のACMチューリング賞の講演で説明している。Backusによると

確かに、フォン・ノイマン・ボトルネックを通って膨大な数の言葉を前後に押すよりも、ストアの中で大きな変化を起こすためには、もっと原始的な方法があるはずです。このボトルネックは、問題のデータトラフィックの文字通りのボトルネックであるだけでなく、もっと重要なのは、私たちが目の前のタスクのより大きな概念的な単位で考えることを奨励する代わりに、単語単位の思考に縛られ続けてきた知的なボトルネックでもあるということです。このように、プログラミングは基本的には、フォン・ノイマンのボトルネックを通る膨大な言葉のトラフィックを計画し、詳細に記述することであり、そのトラフィックの多くは、重要なデータそのものではなく、どこでそれを見つけるかに関係しているのです。



### On Computable Numbers, with an Application to the Entscheidungsproblem

https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf

"計算可能"数とは、10進数としての式が有限の手段で計算可能な実数を簡単に説明することができます。

本論文の主題は表向きは計算可能数であるが，積分変数や実数・計算可能変数の計算可能関数，計算可能述語などを定義して調べることはほぼ同様に容易である．しかし，基本的な問題はそれぞれのケースで同じであり，私は，最も面倒な技術を必要としないものとして，計算可能数を明示的に扱うことにしました．近いうちに、計算可能数や関数などの関係を説明したいと思っています。これには，計算可能数で表現された実数変数の関数の理論を発展させることも含まれます．私の定義によると，計算可能な数は，その10進数が機械で書き留められる場合に計算可能である．



### *Entscheidungsproblem*

[Entscheidungsproblem(en.wikipedia)](https://en.wikipedia.org/wiki/Entscheidungsproblem)

数学とコンピュータサイエンスでは、エンツァイトシャイトungsproblem（発音[ɛntˈʃaɪ̯dʊŋspʁoˌbleːm]、"決定問題 "のためのドイツ語）は、1928年にデビッド・ヒルベルトとヴィルヘルム・アッカーマンによって提起された課題です。問題は、文が普遍的に有効であるかどうかに応じて、入力として、文と答え "はい "または "いいえ "を考慮したアルゴリズムを求めている、すなわち、公理を満たすすべての構造で有効です。



### Universal Turing machine

[Universal_Turing_machine(en.wikipedia)](https://en.wikipedia.org/wiki/Universal_Turing_machine)

コンピュータ・サイエンスでは、ユニバーサル・チューリング・マシン(UTM)とは、任意の入力で任意のチューリング・マシンをシミュレートするチューリング・マシンのことです。ユニバーサル・チューリング・マシンは、シミュレーションされるマシンの記述と、それ自身のテープからそのマシンへの入力の両方を読み取ることによって、これを本質的に達成します。アラン・チューリングは1936-1937年にそのような機械のアイデアを導入しました。この原理は、1946年にジョン・フォン・ノイマンが現在のフォン・ノイマンの名を冠した「電子計算機」のために使用したストアド・プログラム・コンピュータのアイデアの起源であると考えられています：フォン・ノイマン・アーキテクチャ。

計算の複雑さという点では、マルチテープ・ユニバーサル・チューリング・マシンは、シミュレーションするマシンと比較して対数的に遅くなるだけでよいのです。

すべてのチューリングマシンは、そのアルファベット上の入力文字列から、ある固定された部分的な計算可能な関数を計算します。その意味では、それは固定されたプログラムを持つコンピュータのように振る舞います。しかし、どんなチューリング・マシンの動作表も文字列でエンコードすることができます。このようにして、動作表を記述した文字列と入力テープを記述した文字列をテープに期待し、エンコードされたチューリング・マシンが計算したであろうテープを計算するチューリング・マシンを構築することができます。チューリングは1936年の論文でそのような構造を完全に詳細に記述しています。

"どんな計算可能なシーケンスでも計算するために使われる単一の機械を発明することが可能です。もしこの機械Uが、ある計算機MのS.D [アクション・テーブルの "標準記述 "が書かれたテープと一緒に供給されるならば、UはMと同じシーケンスを計算するでしょう。

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/Von_Neumann_Architecture.svg/2880px-Von_Neumann_Architecture.svg.png)



## System bus

[System_bus(en.wikipedia)](https://en.wikipedia.org/wiki/System_bus)

システムバスとは、情報を運ぶためのデータバス、送信先を決定するためのアドレスバス、動作を決定するための制御バスの機能を組み合わせて、コンピュータシステムの主要なコンポーネントを接続する単一のコンピュータバスのことです。この技術は、コスト削減とモジュール性の向上のために開発されたもので、1970年代と1980年代に人気がありましたが、現代のコンピュータでは、より特定のニーズに合わせて様々な別個のバスを使用しています。

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Computer_system_bus.svg/2880px-Computer_system_bus.svg.png)

### 背景シナリオ

計算機の多くは、1945年に発表されたEDVAC報告書の第一稿に基づいている。フォン・ノイマン・アーキテクチャとして知られるようになったものでは、中央制御ユニットと算術論理ユニット（ALU、彼は中央演算部と呼んでいた）をコンピュータ・メモリと入出力機能と組み合わせてストアド・プログラム・コンピュータを構成していた。 この報告書はコンピュータの一般的な組織と理論モデルを提示していたが、そのモデルを実装したものではなかった。 間もなく、制御ユニットとALUが中央処理装置（CPU）として知られるようになった。

1950年代と1960年代のコンピュータは、一般的にアドホックな方法で構築されていた。例えば、CPU、メモリ、および入出力ユニットは、ケーブルで接続された1つまたは複数のキャビネットであった。エンジニアは、標準化されたワイヤの束という一般的な技術を使用し、これらの初期のマシンでプリント回路基板を保持するためにバックプレーンが使用されたように、この概念を拡張しました。バス」という名称は、初期の機械式計算機を含む電気機械のさまざまな部分に電力を運ぶ「バスバー」にすでに使用されていた[3] 。 集積回路の出現により、各コンピュータユニットのサイズが大幅に縮小され、バスはより標準化された[4] 。 標準モジュールは、より均一な方法で相互接続でき、開発と保守がより容易になった。



# アーキテクチャ一覧

## ppc64
[Ppc64(en.wikipedia)](https://en.wikipedia.org/wiki/Ppc64)

ppc64は、Linux、GNU Compiler Collection (GCC)、およびLLVMオープンソースソフトウェアコミュニティで一般的に使用されている識別子であり、64ビットのビッグエンディアンPowerPCおよびPower ISAプロセッサ用に最適化されたアプリケーションのターゲットアーキテクチャを参照するために使用されています[1]。

ppc64leは、OpenPOWER Foundationが提供する技術をプライムターゲットとしてPOWER8で導入された純粋なリトルエンディアンモードであり、x86 Linuxベースのソフトウェアを最小限の労力で移植できることを目的としている[2]。

これら2つの識別子は、ソースコードをコンパイルする際に、ターゲットアーキテクチャを識別するために頻繁に使用されます[3]。

#### ABI

http://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi.html

ELFはコンパイルされたアプリケーションプログラムのためのリンクインタフェースを定義しています。ELFは2つの部分で記述されています。最初の部分は一般的なSystem V ABIです。第二部は、プロセッサ固有の補足資料です。

このドキュメントは、64 ビット PowerPC® プロセッサ・システムで ELF を使用するためのプロセッサ固有の補足資料です。

本書は、ライブラリ・インターフェースを定義していないため、完全なSystem V Application Binary Interface Supplementではありません。

64ビットPowerPCアーキテクチャ™では、プロセッサはビッグエンディアンモードとリトルエンディアンモードの2つのモードのいずれかで実行することができます（第3.1.3項参照）。したがって、このABI仕様では、実際にはビッグエンディアンABIとリトルエンディアンABIの2つのバイナリインタフェースを定義しています。ビッグエンディアン・インターフェースの実装上で実行されるプログラムや（一般的に）生成されたデータは、リトルエンディアン・インターフェースの実装には移植できませんし、その逆も同様です。64ビットPowerPC ELF ABIは32ビットPowerPC ELF ABIと同じではなく、単純な拡張でもありません。64ビットPowerPC ELF ABIをサポートするシステムは、32ビットPowerPC ELF ABIをサポートする必要はありませんが、64ビットPowerPC ELF ABIをサポートする必要はありません。

64ビットPowerPC ELF ABIは、64ビットPowerOpen ABIと同じ構造レイアウトと呼び出し規則を使用することを意図しています。

## 386

[Intel_80386(en.wikipedia)](https://en.wikipedia.org/wiki/Intel_80386)

インテルの 80386（i386 または 386 とも呼ばれる）は、1985 年に発表された 32 ビット・マイクロプロセッサである[2] 。 最初のバージョンは 275,000 トランジスタ[3] を搭載しており、当時の多くのワークステーションやハイエンド・パーソナル・コンピュータの CPU として使用されていた。80286アーキテクチャの32ビット拡張のオリジナルの実装として[4]、80386命令セット、プログラミングモデル、およびバイナリエンコーディングは、現在でもすべての32ビットx86プロセッサの共通分母となっており、文脈に応じてi386-アーキテクチャ、x86、またはIA-32と呼ばれています。

32 ビットの 80386 は、初期の PC に広く普及していた 8086 や 80286 などの初期の 16 ビットプロセッサ向けのコードのほとんどを正しく実行できます。(同じ伝統を踏襲して、現代の 64 ビット x86 プロセッサは、1978 年のオリジナルの 16 ビット 8086 までさかのぼって、古い x86 CPU 向けに書かれたほとんどのプログラムを実行することができます)。長年にわたり、同じアーキテクチャの新しい実装が次々と登場し、オリジナルの 80386 の数百倍（8086 の数千倍）の速さになってきた[5] 。 33MHz の 80386 は、約 11.4MIPS で動作すると報告されている[6]。

80386は1985年10月に発売され、1986年6月からチップの大量生産が開始された[7][8] 。 80386ベースのコンピュータシステムのメインボードは、当初は煩雑で高価だったが、80386が主流になると製造が合理化された。80386を採用した最初のパーソナルコンピュータはCompaq社が設計・製造した[9]が、IBM PC互換デファクトスタンダードの基本コンポーネントがIBM以外の企業によって初めて更新された。

2006年5月、インテルは80386の生産を2007年9月末で終了することを発表した[10]。このようなシステムは、航空宇宙技術や電子楽器などでは、80386や多くの派生製品の1つを使用するのが一般的である。一部の携帯電話では、BlackBerry 950[11] や Nokia 9000 Communicator などの 80386 プロセッサ（後に完全にスタティック CMOS 化したもの）も使用されていた。Linux は 2012 年 12 月 11 日まで 80386 プロセッサをサポートし続けたが、カーネルがバージョン 3.8 で 386 固有の命令をカットしたときには[12] 、80386 プロセッサはサポートされなかった。



| Launched                                                     | October 1985                                                 |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| Discontinued                                                 | September 28, 2007[[1\]](https://en.wikipedia.org/wiki/Intel_80386#cite_note-1) |
| Common manufacturer(s)                                       | IntelAMDIBM                                                  |
| Performance                                                  |                                                              |
| Max. [CPU](https://en.wikipedia.org/wiki/Central_processing_unit) [clock rate](https://en.wikipedia.org/wiki/Clock_rate) | 12 MHz to 40 MHz                                             |
| Data width                                                   | 32 bits (386SX: 16 bit)                                      |
| Address width                                                | 32 bits (386SX: 24 bits)                                     |
| Architecture and classification                              |                                                              |
| [Min. feature size](https://en.wikipedia.org/wiki/Technology_node) | 1.5µm to 1µm                                                 |
| [Instruction set](https://en.wikipedia.org/wiki/Instruction_set_architecture) | [x86-32](https://en.wikipedia.org/wiki/X86-32)               |
| Physical specifications                                      |                                                              |
| [Transistors](https://en.wikipedia.org/wiki/Transistor_count) | 275,000                                                      |
| [Co-processor](https://en.wikipedia.org/wiki/Co-processor)   | [Intel 80387](https://en.wikipedia.org/wiki/X87#80387)       |
| Package(s)                                                   | 132-pin [PGA](https://en.wikipedia.org/wiki/Pin_grid_array), 132-pin [PQFP](https://en.wikipedia.org/wiki/Plastic_quad_flat_package); SX variant: 88-pin PGA, 100-pin [BQFP](https://en.wikipedia.org/wiki/Bumpered_quad_flat_package) with 0.635mm pitch |
| Socket(s)                                                    | [PGA132](https://en.wikipedia.org/wiki/Pin_Grid_Array)       |
| History                                                      |                                                              |
| Predecessor                                                  | [Intel 80286](https://en.wikipedia.org/wiki/Intel_80286)     |
| Successor                                                    | [Intel 80486](https://en.wikipedia.org/wiki/Intel_80486)     |

### Architecture

このプロセッサは、x86アーキテクチャを大きく進化させたもので、Intel 8008まで延びた長いプロセッサのラインを延長したものだった。80386の前身は、セグメントベースのメモリ管理および保護システムを搭載した16ビットプロセッサであるIntel 80286であった。80386では、3段命令パイプラインが追加され、アーキテクチャが16ビットから32ビットに拡張され、オンチップのメモリ管理ユニットが追加された。このページング変換ユニットにより、仮想メモリを使用するオペレーティングシステムの実装が大幅に容易になった。また、レジスタデバッグのサポートも提供された。

80386には、リアルモード、プロテクトモード、バーチャルモードの3つの動作モードが搭載されている。286でデビューしたプロテクトモードは、386で最大4GBのメモリをアドレス指定できるように拡張された。新しいバーチャル8086モード（VM86）では、一部のプログラムには互換性がないものもあったが、保護された環境で1つ以上のリアルモードのプログラムを実行することが可能になった。

386はすべてのモードでセグメント化されたメモリモデルを使用しているにもかかわらず、保護されたモードではフラットなメモリモデルを使用しているかのように設定できるようになったことは、AMDが2003年にx86-64をリリースするまで、x86プロセッサファミリーにとって最も重要な機能変更であったと言って間違いないだろう。

386にはいくつかの新しい命令が追加された。BSF、BSR、BT、BTS、BTR、BTC、CDQ、CWDE、LFS、LGS、LSS、MOVSX、MOVZX、SETcc、SHLD、SHRD。

汎用プログラム用に2つのセグメント・レジスタ(FSとGS)が追加され、286の1つのマシン・ステータス・ワードが8つのコントロール・レジスタCR0-CR7に拡張されました。デバッグ・レジスタDR0-DR7はハードウェア・ブレークポイント用に追加されました。MOV命令の新しい形式は、それらにアクセスするために使用されます。

80386の開発におけるチーフ・アーキテクトはJohn H. Crawfordである[13] 。彼は80286アーキテクチャと命令セットを32ビットに拡張する責任者であり、その後、80386チップのマイクロプログラム開発を主導した。

80486およびP5 Pentiumプロセッサのラインは、80386設計の末裔である。

### Datatypes

以下のデータ型は直接サポートされているため、1 つ以上の 80386 マシン命令で実装されています。

ビット（ブール値）、ビットフィールド（最大32ビットのグループ）、ビット文字列（長さ4Gビットまで）。
8ビット整数（バイト）、符号付き（範囲-128～127）または符号なし（範囲0～255）。
16ビット整数、符号付き（範囲-32,768...32,767）または符号なし（範囲0...65,535）のいずれか。
32 ビット整数、符号付き (範囲 -231...231-1) または符号なし (範囲 0...232-1)。
64 ビット整数、符号付き (範囲 -263...263-1) または符号なし (範囲 0...264-1)。
オフセット ： メモリ位置を参照する 16 または 32 ビットの変位 （任意のアドレッシングモードを使用）。
ポ イ ン タ ー、16 ビットのセレクタと 16 ビットまたは 32 ビットのオ フ セ ッ ト 。
文字（8 ビット文字コード）。
文字列。8 ビット、16 ビット、または 32 ビットのワードのシーケンス（長さは最大 4Gbit）[15]。
BCD、アンパックされたバイトで表現される10進数（0～9）。
パックされたBCD、1バイトに2つのBCD桁（範囲0～99）。

## x86-64(AMD64)

[X86-64(en.wikipedia)](https://en.wikipedia.org/wiki/X86-64)

x86-64 (x64、x86_64、AMD64、Intel 64 としても知られています) は、x86 命令セットの 64 ビット版です。64ビットモードと互換性モードの2つの新しい動作モードと、新しい4レベルのページングモードが導入されています。64ビットモードと新しいページングモードでは、32ビット版の前身と比べて大容量の仮想メモリと物理メモリをサポートし、プログラムがより大容量のデータをメモリに格納できるようになっています。浮動小数点演算は必須のSSE2ライクな命令でサポートされており、x87/MMXスタイルのレジスタは一般的には使用されません（64ビットモードでも使用可能です）。その代わりに、32個のベクトルレジスタのセットが使用されます(各レジスタには、1つまたは2つの倍精度の数値、または1～4つの単精度の数値、またはさまざまな整数形式を格納できます)。64ビットモードでは、命令は64ビットオペランドと64ビットアドレッシングモードをサポートするように変更されます。互換モードでは、64ビット・オペレーティング・システムがサポートしている場合、16ビットおよび32ビットのユーザー・アプリケーションを64ビット・アプリケーションと変更せずに共存させて実行することができます 、完全なx86 16ビットおよび32ビット命令セットがハードウェアに実装されたままであるため、これらの古い実行可能ファイルは性能の低下をほとんど感じずに実行できます。また、x86-64をサポートするプロセッサは、80286以降のx86プロセッサと同様に、完全な下位互換性を実現するためにリアルモードで電源を入れます。

AMDが作成し、2000年にリリースされたオリジナル仕様は、AMD、Intel、VIAの3社が実装している。OpteronやAthlon 64プロセッサに搭載されたAMDのK8マイクロアーキテクチャが最初に実装された。これは、Intel以外の会社が設計したx86アーキテクチャへの最初の大きな追加だった。Intelは追随を余儀なくされ、AMDの仕様とソフトウェア互換性のある修正NetBurstファミリを発表した。VIA Technologiesは、VIA IsaiahアーキテクチャのVIA Nanoでx86-64を導入した。

x86-64アーキテクチャは、Intel Itaniumアーキテクチャ(旧IA-64)とは一線を画しており、x86アーキテクチャとはネイティブ命令セットレベルでの互換性がない。一方のアーキテクチャ用にコンパイルされたオペレーティングシステムやアプリケーションは、もう一方のアーキテクチャでは実行できません。

### x86 から見た x86-64

[X86#x86-64(en.wikipedia)](https://en.wikipedia.org/wiki/X86#x86-64)

2000 年代になると、32 ビット x86 プロセッサのメモリ・アドレッシングの限界が、ハイパフォーマンス・コンピューティング・クラスターや強力なデスクトップ・ワークステーションでの利用の障害となってきました。老朽化した32ビットx86は、より多くのメモリをアドレス指定できる、より高度な64ビットRISCアーキテクチャと競合していました。インテルとx86エコシステム全体が、x86が64ビット・コンピューティング時代を生き抜くためには、64ビット・メモリ・アドレッシングを必要としていました。しかし、Intelは、64ビット・デスクトップ・コンピュータへの移行をx86アーキテクチャからの移行に利用するという大胆な一歩を踏み出すべき時期だと考えていましたが、この実験は最終的に失敗に終わりました。

2001年、インテルは、IA-64と名付けられた非x86 64ビット・アーキテクチャをItaniumプロセッサに導入しようと試みた。 IA-64はx86と互換性がなかったが、Itaniumプロセッサはx86命令をIA-64に変換するためのエミュレーション機能を提供したが、これはx86プログラムの性能にひどく影響するため、ユーザーにとって実際に役立つことはほとんどなかった。Itaniumプロセッサは下位互換性を破り、x86チップを使い続けることを好むため、市場はItaniumプロセッサを拒絶し、IA-64用に書き換えられたプログラムはほとんどなかった。

AMDは、下位互換性が損なわれないようにするために、64ビットメモリアドレッシングに向けて別の道を歩むことにした。2003年4月、AMDは64ビット汎用レジスタを搭載した初のx86プロセッサ「Opteron」を発表しましたが、これは新しいx86-64拡張機能（AMD64またはx64とも呼ばれる）を使用して4GB以上の仮想メモリをアドレス指定できるようになりました。x86 アーキテクチャへの 64 ビット拡張は、新たに導入されたロングモードでのみ有効になるため、32 ビットおよび 16 ビットのアプリケーションやオペレーティング システムは、性能をわずかに犠牲にすることなく[31]、16 ビットの Intel 8086 の元の命令と完全に互換性を保ったまま、保護されたモードやその他のモードで AMD64 プロセッサを使用し続けることができました[32](p13-14)。

市場が互換性のないItaniumプロセッサを拒絶し、MicrosoftがAMD64をサポートしているのを見て、Intelはこれに対応せざるを得ず、2004年7月に独自のx86-64プロセッサ、"Prescott" Pentium 4を発表した[33]。

x86-64では、バッファオーバーランによるセキュリティバグからある程度保護するNXビットも導入されました。

AMDがx86の系譜に64ビットで貢献し、その後Intelに受け入れられた結果、64ビットRISCアーキテクチャはx86エコシステムにとって脅威ではなくなり、ワークステーション市場からほとんど姿を消しました。x86-64は強力なスーパーコンピュータ（AMD OpteronやIntel Xeonの化身）で利用されるようになりました。64ビット・コンピューティングへの大きな飛躍と、32ビットおよび16ビット・ソフトウェアとの下位互換性の維持により、x86アーキテクチャは今日では非常に柔軟なプラットフォームとなり、x86チップは小型の低消費電力システム（例えば、Intel QuarkやIntel Atom）から高速なゲーム用デスクトップ・コンピュータ（例えば、Intel Core i7やAMD FX/Ryzen）まで利用され、さらには大規模なスーパーコンピューティング・クラスタを支配しており、スマートフォンやタブレット市場での競合相手としてARMの32ビットおよび64ビットRISCアーキテクチャだけが事実上残されています。



## ARM

[ARM_architecture(en.wikipedia)](https://en.wikipedia.org/wiki/ARM_architecture)

ARMは、以前はAdvanced RISC Machine、当初はAcorn RISC Machineと呼ばれていましたが、様々な環境に合わせて構成されたコンピュータ・プロセッサ用の縮小命令セット・コンピューティング(RISC)アーキテクチャのファミリーです。ARM社は、このアーキテクチャを開発し、他社にライセンス供与しています。他社は、このアーキテクチャのいずれかを実装した製品（メモリ、インターフェース、無線などを組み込んだシステムオンチップ（SoC）やシステムオンモジュール（SoM）を含む）を設計しています。また、この命令セットを実装するコアを設計し、そのコア設計を自社製品に組み込む多くの企業にライセンス供与しています。

RISCアーキテクチャを採用したプロセッサは、複雑な命令セット・コンピューティング（CISC）アーキテクチャ（ほとんどのパーソナル・コンピュータに搭載されているx86プロセッサなど）を採用したプロセッサに比べて、一般的に必要なトランジスタ数が少なく、コスト、消費電力、放熱性が向上します。これらの特性は、スマートフォン、ノートパソコン、タブレットコンピュータなどの軽量で持ち運び可能なバッテリ駆動の機器や、その他の組み込みシステム[3][4][5]に適していますが、サーバやデスクトップにもある程度有用な特性があります。また、大量の電力を消費するスーパーコンピュータでは、ARMは電力効率の良いソリューションでもある[6]。

アームホールディングスは定期的にアーキテクチャのアップデートをリリースしています。アーキテクチャのバージョンARMv3からARMv7では、32ビットのアドレス空間（Arm Holdingsが設立される前に製造されたARMv3以前のチップは、Acorn Archimedesで使用されていたように26ビットのアドレス空間）と32ビットの演算をサポートしており、ほとんどのアーキテクチャでは32ビットの固定長命令が使用されています。Thumbバージョンは、コード密度を向上させるために32ビット命令と16ビット命令の両方を提供する可変長命令セットをサポートしています。一部の古いコアではJavaバイトコードのハードウェア実行も可能で、新しいコアではJavaScript用の命令が1つあります。2011年にリリースされたARMv8-Aアーキテクチャでは、新しい32ビット固定長命令セットにより、64ビットアドレス空間と64ビット演算のサポートが追加されました[7]。オートモーティブ・アプリケーション向けのARM Cortex-A65AEもマルチスレッド・プロセッサで、フォールト・トレラント設計のためのデュアル・コア・ロックステップを備えています（最高レベルのオートモーティブ・セーフティ・インテグリティ・レベルDをサポートしています）。Neoverse N1は、「最小8コア」または「単一のコヒーレント・システム内で64コアから128コアのN1コアにスケールする設計」向けに設計されている[8]。

2019年現在、1,300億個以上のARMプロセッサが生産されており[9][10][11][12]、ARMは最も広く使用されている命令セットアーキテクチャ（ISA）であり、最も多く生産されているISAである[13][4][14][15][16]現在、広く使用されているCortexコア、古い「クラシック」コア、特化したSecurCoreコアの亜種があり、それぞれにオプション機能を含めたり除外したりすることが可能である。



### 概要

[ARMアーキテクチャ(ja.wikipedia.org)](https://ja.wikipedia.org/wiki/ARMアーキテクチャ)

ARMアーキテクチャは消費電力を抑える特徴を持ち、低消費電力を目標に設計される[モバイル機器](https://ja.wikipedia.org/wiki/携帯機器)において支配的となっている。本アーキテクチャの[命令セット](https://ja.wikipedia.org/wiki/命令_(コンピュータ))は「（基本的に）固定長の命令」「簡素な命令セット」という[RISC](https://ja.wikipedia.org/wiki/RISC)風の特徴を有しつつ、「条件実行、定数シフト/ローテート付きオペランド、比較的豊富なアドレッシングモード」といった[CISC](https://ja.wikipedia.org/wiki/CISC)風の特徴を併せ持つのが特徴的だが、これは初期のARMがパソコン向けに設計された際、当時の同程度の性能のチップとしてはかなり少ないゲート数（約25,000トランジスタ）で実装されたチップの多くの部分を常に活用する設計として工夫されたもので、回路の複雑さを増さないという方向性だというように見れば、CISC風の特徴というよりむしろRISC風の特徴とも言える。ともあれ以上のような設計が、初期の世代の実装において、（性能の割に）低消費電力、小さなコア、（RISCとしては）高いコード密度といった優れた特性に結びつき、広く普及する原動力となった。

2005年の時点で、ARMファミリーは[32ビット](https://ja.wikipedia.org/wiki/32ビット)[組込み](https://ja.wikipedia.org/wiki/組み込みシステム)[マイクロプロセッサ](https://ja.wikipedia.org/wiki/マイクロプロセッサ)（乃至、特にマイクロコントローラ）のおよそ75%を占め[[2\]](https://ja.wikipedia.org/wiki/ARMアーキテクチャ#cite_note-2)、全世界で最も使用されている32ビットCPUアーキテクチャである[*[要出典](https://ja.wikipedia.org/wiki/Wikipedia:「要出典」をクリックされた方へ)*]。ARMアーキテクチャに基づくCPUコアは、[PDA](https://ja.wikipedia.org/wiki/携帯情報端末)・[携帯電話](https://ja.wikipedia.org/wiki/携帯電話)・[メディアプレーヤー](https://ja.wikipedia.org/wiki/メディアプレーヤー)・[携帯型ゲーム](https://ja.wikipedia.org/wiki/携帯型ゲーム)・[電卓](https://ja.wikipedia.org/wiki/電卓)などの携帯機器から、[ハードディスク](https://ja.wikipedia.org/wiki/ハードディスク)・[ルータ](https://ja.wikipedia.org/wiki/ルータ)などの[PC](https://ja.wikipedia.org/wiki/パーソナルコンピュータ)周辺機器まで、あらゆる電子機器に使用される。2013年現在、[NEC](https://ja.wikipedia.org/wiki/日本電気)のEMMA MobileはCortex-A9を[[3\]](https://ja.wikipedia.org/wiki/ARMアーキテクチャ#cite_note-3)や[日立](https://ja.wikipedia.org/wiki/日立製作所)系の[SuperH](https://ja.wikipedia.org/wiki/SuperH)系のSH Mobile GシリーズはARMを内蔵するなど、携帯電話では100%近いシェアがある[*[要出典](https://ja.wikipedia.org/wiki/Wikipedia:「要出典」をクリックされた方へ)*]。

携帯機器や電子機器の高性能化に伴いARMコアの出荷数は加速度的に伸びており、2008年1月の時点で100億個以上、2010年9月の時点で200億個以上が出荷されている。ARMアーキテクチャを使用したプロセッサの例としては、[テキサス・インスツルメンツ](https://ja.wikipedia.org/wiki/テキサス・インスツルメンツ)の[OMAP](https://ja.wikipedia.org/wiki/OMAP)シリーズや[マーベル・テクノロジー・グループ](https://ja.wikipedia.org/wiki/マーベル・テクノロジー・グループ)の[XScale](https://ja.wikipedia.org/wiki/XScale)、[NVIDIA](https://ja.wikipedia.org/wiki/NVIDIA)の[Tegra](https://ja.wikipedia.org/wiki/NVIDIA_Tegra)、[クアルコム](https://ja.wikipedia.org/wiki/クアルコム)の[Snapdragon](https://ja.wikipedia.org/wiki/Snapdragon)、[フリースケール](https://ja.wikipedia.org/wiki/フリースケール・セミコンダクタ)のi.MXシリーズ、[ルネサス エレクトロニクス](https://ja.wikipedia.org/wiki/ルネサスエレクトロニクス)のRZファミリ、Synergyなどがある。

既存のARMプロセッサは組み込みとクライアントシステムに特化していたため全て[32ビット](https://ja.wikipedia.org/wiki/32ビット)であるが、顧客からは電力効率に優れるARMアーキテクチャの[サーバ](https://ja.wikipedia.org/wiki/サーバ)への応用を望む声が高まり[*[要出典](https://ja.wikipedia.org/wiki/Wikipedia:「要出典」をクリックされた方へ)*]、ARM社は2011年10月27日、ARMの[64ビット](https://ja.wikipedia.org/wiki/64ビット)拡張であるARMv8アーキテクチャを発表した。

### 命令セット

ARM は RISC プロセッサであり、Thumb 命令ではなく ARM 命令の場合、その命令セットは

- 32ビット固定長命令
- ロード/ストアアーキテクチャ
- 3オペランドのレジスタ間演算
- 多くの命令が1サイクルで実行可能

といった、多くの32ビットRISCプロセッサに共通する特徴が見られる。

ARMプロセッサは、[PC](https://ja.wikipedia.org/wiki/レジスタ_(コンピュータ)#プログラムカウンタ)相対アドレッシングやプレ-/ポスト-インクリメント・アドレッシングモードなど、RISCとみなされる他のアーキテクチャと比べ、豊富な[アドレッシングモード](https://ja.wikipedia.org/wiki/アドレッシングモード)を持っている。

もう一つ留意すべきことは、ARMの命令セットが時間とともに増加しているということである。例えば、初期のARMプロセッサ（ARM7TDMIより以前のもの）は2バイトの値をロードする命令がなかった。

### ARMの例

#### 条件分岐

```assembly
 loop
        CMP    Ri, Rj       ; i と j を比較
        SUBGT  Ri, Ri, Rj   ; もし "GT" ならば i = i - j;  
        SUBLT  Rj, Rj, Ri   ; もし "LT" ならば j = j - i; 
        BNE    loop         ; もし "NE" ならば loop に戻る
```

多くのARMプログラムは通常RISCプロセッサに期待されるようなプログラムよりも密度の高いものになる。このため、命令フェッチに伴うメモリへのアクセス頻度が少なくなり、分岐に伴うストールも回避しやすく、パイプライン処理を効率的に使うことができる。このことが、ARMがARMより複雑なCPUデザインと競合することを可能にした特徴的な一因のひとつである。

#### Thumb

ARMプロセッサは**Thumb**と呼ばれるコード効率の向上を意図した[16ビット](https://ja.wikipedia.org/wiki/16ビット)長の命令モードを持っている([SuperH](https://ja.wikipedia.org/wiki/SuperH)の命令16ビット/データ32ビットに倣い追加された)。条件実行のための4ビットプレディケートが削除されている。メモリポートやバスが32ビットよりも狭い状況において32ビットコードよりも性能が向上する。多くの場合、組み込みアプリケーションでは32ビットのデータパスを持っているのは一部のアドレス範囲のみであり（例: [ゲームボーイアドバンス](https://ja.wikipedia.org/wiki/ゲームボーイアドバンス)）、残りは16ビットかそれよりも狭くなっている。このような状況では、Thumbコードをコンパイルし、CPUに最も負荷のかかる部分だけを32ビット長の命令セットを使用して手作業で最適化するのが、通常は理にかなっている。Thumb命令とARM命令は単一の実行ファイル内で混在が可能であるが、Thumb命令を実行できるモードとARM命令を実行できるモードは独立しており、両者を使うにはその都度プロセッサの状態を切り替える必要がある。状態の切り替えは分岐命令 (BX, BLX) で行うことができるため、通常は関数単位でThumb命令とARM命令を使い分け、関数呼び出しの際に切り替えを行うのが一般的である。

Thumbテクノロジを搭載した最初のプロセッサはARM7TDMIである。ARM9とそれ以降のファミリは、[XScale](https://ja.wikipedia.org/wiki/XScale)も含めて全てThumbテクノロジを搭載している。



## ARM64

[ARMアーキテクチャ(ja.wikipedia.org)](https://ja.wikipedia.org/wiki/ARMアーキテクチャ)

ARMv8-Aから採用。ARMの64ビットモードアーキテクチャAArch64では、汎用レジスタはすべて64ビットとなり、数も16個から31個に増やされる。サーバ用途も意識して[仮想化](https://ja.wikipedia.org/wiki/仮想化)支援命令および[暗号](https://ja.wikipedia.org/wiki/暗号)支援命令が追加され、[SIMD](https://ja.wikipedia.org/wiki/SIMD)拡張命令であるNEONも大幅に強化される。

### 命令セットの特徴

汎用レジスタの増加と64ビット化に伴い、命令セットは完全に再定義されている。コード効率を重視して命令長は32ビットのままで、32ビットARMの特徴であった条件付き実行命令の大半が削除される。これによって一般的なRISC命令セットに近くなったが、依然としてコードサイズを小さくするための工夫が随所に織り込まれている。

AArch64モードにおける命令セットはA64と呼ばれ、以下にA64命令セットの特徴を示す。

- 即値シフト付きオペランド

  これは従来の32ビットARM命令セットにおいて*フレキシブル第2オペランド (Flexible second operand)* と呼ばれていたものに相当する。多くの基本的な演算命令においては、入力オペランドのうち1つに対する操作を即値左シフト、即値論理右シフト、即値算術右シフト、シフトなし、の4つから選択することができ、演算命令と即値シフト命令を一体化することができる。なお、従来とは異なりローテートは不可能となった。

- 条件付き実行命令

  汎用レジスタ数が倍増したのに伴い、基本命令の多くからは条件付き実行機能が削除されたが、それでも比較的豊富な条件付き実行命令が定義されている。代表的なものを挙げるとCCMP（条件付き比較）、CINC（条件付きインクリメント）、CSEL（条件付き選択; いわゆるCMOV）等が存在する。

- Compare-and-Branch命令

  PC相対分岐においては、ゼロフラグを参照する場合のみであるが比較と条件分岐を1命令で行うことが可能になっている (CBZ/CBNZ)。これは従来Thumb-2命令セットでのみ定義されていたものであるが、A64モードでは基本命令として定義されている。

- 符号拡張/ゼロ拡張付き命令

  算術演算/比較命令については、入力オペランドのうち1つを8,16,32ビットから32もしくは64ビットに符号/ゼロ拡張するバージョンが用意されている。

汎用レジスタは64ビット幅であるが、多くの演算命令にはレジスタの下位32ビットのみを参照する32ビット命令が用意されている。この場合、レジスタの部分書き換えが発生しないように、演算結果の32ビットの値は暗黙のゼロ拡張が行われた上で64ビットレジスタに格納される。

### SIMD and Floating-point (NEON) 命令

A64命令セットにおいては従来のVFPとAdvanced SIMD (NEON) は統合され、一つの命令体系となった。これに伴い、名称については単にSIMD and Floating-point命令と呼ばれるようになった。

主な変更点は倍精度浮動小数点演算への対応、IEEE754への準拠、レジスタ本数の増加の3点である。レジスタについては128ビットのレジスタが32本に増加している。依然として64ビットレジスタとしてアクセスすることも可能であるが、32ビットモードとは異なり、64ビットレジスタは128ビットレジスタの下位64ビットにマッピングされている。

VFPとAdvanced SIMDの統合に伴い、従来はVFPが担っていたスカラの浮動小数点演算命令は、SIMDレジスタのうち下位の32/64ビットにのみ作用する命令として再定義されている。例えば浮動小数点加算命令については

```assembly
 fadd  s2, s1, s0             ; s2 <= s0 + s1（単精度スカラ）
 fadd  d2, d1, d0             ; d2 <= d0 + d1（倍精度スカラ）
 fadd  v2.4s, v1.4s, v0.4s    ; [v2] <= [v0] + [v1]（単精度x4 SIMD）
 fadd  v2.2d, v1.2d, v0.2d    ; [v2] <= [v0] + [v1]（倍精度x2 SIMD）
```

のようなバリエーションが命令のニーモニックを保ちつつ、オペランドのプレフィックス (s, d, v) とサフィックスを変更することによって記述可能になっている（サフィックスについては、一部の環境向けのアセンブラではニーモニック側に付加する省略記法も許されるようである）。これはx86プロセッサのSSE命令セットがスカラ命令とSIMD命令の双方を備えているのとよく似ている。



## wasm

## mips

## mips64

## mips64le

## mipsle

## ppc64

## ppc64le

## riscv64

## s390x
