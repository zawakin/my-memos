# このページでまとめたアーキテクチャ一覧

- ppc64
- 386
- amd64
- arm
- arm64
- wasm
- mips
- mips64
- mips64le
- mipsle
- ppc64
- ppc64le
- riscv64
- s390x





# コンピュータ・アーキテクチャ

[コンピュータ・アーキテクチャ(ja.wikipedia.org)](https://ja.wikipedia.org/wiki/コンピュータ・アーキテクチャ)

## 命令セットアーキテクチャ

- RISC
- CISC
- VLIW
- EPICアーキテクチャ

（実装例）x86(IA-32)、PowerPC、SPARCなど。

## マイクロアーキテクチャ

- 演算アーキテクチャ
  [浮動小数点](https://ja.wikipedia.org/wiki/浮動小数点)、[演算装置](https://ja.wikipedia.org/wiki/演算装置)、[SIMD](https://ja.wikipedia.org/wiki/SIMD)/[MIMD](https://ja.wikipedia.org/wiki/MIMD)、[ベクトル演算](https://ja.wikipedia.org/wiki/ベクトル演算)ユニット([ベクトル計算機](https://ja.wikipedia.org/wiki/ベクトル計算機))
- CPU制御アーキテクチャ
  [ワイヤードロジック](https://ja.wikipedia.org/wiki/ワイヤードロジック)、[マイクロプログラム](https://ja.wikipedia.org/wiki/マイクロプログラム方式)（マイクロアーキテクチャ）、[実行ユニット](https://ja.wikipedia.org/wiki/実行ユニット)、[制御装置](https://ja.wikipedia.org/wiki/制御装置)
- CPU高速化アーキテクチャ
  [パイプライン](https://ja.wikipedia.org/wiki/命令パイプライン)、[スーパースケーラ](https://ja.wikipedia.org/wiki/スーパースケーラ)、[アウト・オブ・オーダー実行](https://ja.wikipedia.org/wiki/アウト・オブ・オーダー実行)、[分岐予測](https://ja.wikipedia.org/wiki/分岐予測)、[レジスタ・ウィンドウ](https://ja.wikipedia.org/wiki/レジスタ・ウィンドウ)、[レジスタ・リネーミング](https://ja.wikipedia.org/wiki/レジスタ・リネーミング)、[投機的実行](https://ja.wikipedia.org/wiki/投機的実行)
- CPUバスアーキテクチャ
  CPUバス（CPU内部バス、CPU外部バス《ピン》アーキテクチャ）、[バス (コンピュータ)](https://ja.wikipedia.org/wiki/バス_(コンピュータ))の項を参照。<スタブ>
- [マルチプロセッサ](https://ja.wikipedia.org/wiki/マルチプロセッサ)アーキテクチャ
  [対称型マルチプロセッサ](https://ja.wikipedia.org/wiki/対称型マルチプロセッサ)(SMP)、[NUMA](https://ja.wikipedia.org/wiki/NUMA)(ASMP)、[クロスバースイッチ](https://ja.wikipedia.org/wiki/クロスバースイッチ) <スタブ>
- [マルチスレッド](https://ja.wikipedia.org/wiki/ハードウェアマルチスレッディング)アーキテクチャ
  [ブロック型マルチスレッディング](https://ja.wikipedia.org/wiki/ハードウェアマルチスレッディング#ブロック型マルチスレッディング)、[インターリーブ型マルチスレッディング](https://ja.wikipedia.org/wiki/バレルプロセッサ)、[同時マルチスレッディング](https://ja.wikipedia.org/wiki/同時マルチスレッディング)

## システムアーキテクチャ

- 制御アーキテクチャ
  [割り込み](https://ja.wikipedia.org/wiki/割り込み_(コンピュータ))制御、[入出力](https://ja.wikipedia.org/wiki/入出力)制御

- バスアーキテクチャ

  ハーバードアーキテクチャ

  、プログラム内蔵方式（

  ノイマン型

  を含む）

  クロスバースイッチ

  システムバス、メモリバス、入出力バス。

  バス (コンピュータ)

  の項を参照。<スタブ>

  - （実装例）ISA、PCI等の[拡張バス](https://ja.wikipedia.org/wiki/拡張バス)アーキテクチャ。

- メモリアーキテクチャ
  [キャッシュメモリ](https://ja.wikipedia.org/wiki/キャッシュメモリ)、[仮想記憶](https://ja.wikipedia.org/wiki/仮想記憶)、[TLB](https://ja.wikipedia.org/wiki/トランスレーション・ルックアサイド・バッファ)　<スタブ> -- [メモリ](https://ja.wikipedia.org/wiki/メモリ)

- ネットワークアーキテクチャ
  <スタブ> -- [コンピュータネットワーク](https://ja.wikipedia.org/wiki/コンピュータネットワーク)

- [オペレーティングシステム](https://ja.wikipedia.org/wiki/オペレーティングシステム)アーキテクチャ
  [ページング方式](https://ja.wikipedia.org/wiki/ページング方式)アーキテクチャ。<スタブ>

- [分散処理アーキテクチャー](https://ja.wikipedia.org/wiki/分散処理アーキテクチャー)



![img](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d8/ABasicComputer.gif/481px-ABasicComputer.gif)



## Instruction set architecture

[Instruction_set_architecture(en.wikipedia)](https://en.wikipedia.org/wiki/Instruction_set_architecture)

命令セットアーキテクチャ（ISA）は、コンピュータの抽象モデルです。アーキテクチャやコンピュータアーキテクチャとも呼ばれます。中央処理装置（CPU）などのISAを実現したものを実装と呼びます。

一般的に、ISAは、サポートされるデータ型、レジスタ、メインメモリの基本機能（メモリの整合性、アドレッシングモード、仮想メモリなど）を管理するためのハードウェアサポート、およびISAの実装のファミリの入出力モデルを定義します。

ISAは、そのISAの実装上で実行されるマシンコードの動作を、その実装の特性に依存しない方法で指定し、実装間のバイナリ互換性を提供します。これにより、性能、物理的なサイズ、金銭的なコスト（特に）が異なるISAの複数のインプリメンテーションが可能になり、同じマシンコードを実行することが可能になり、低性能で低コストのマシンを、ソフトウェアを交換することなく、高コストで高パフォーマンスのマシンに置き換えることができます。また、ISAの実装のマイクロアーキテクチャを進化させることができ、ISAのより新しく高性能な実装では、前世代の実装で動作するソフトウェアを実行することができます。

オペレーティングシステムが特定のISAの標準的で互換性のあるアプリケーション・バイナリ・インターフェース（ABI）を維持している場合、そのISAとオペレーティングシステムのマシンコードは、そのISAの将来の実装とそのオペレーティングシステムの新しいバージョンで実行されます。しかし、ISA が複数のオペレーティングシステムの実行をサポートしている場合、最初のオペレーティングシステムが他のオペレーティングシステム用に構築されたマシンコードの実行をサポートしない限り、あるオペレーティングシステム用のマシンコードが他のオペレーティングシステム上で実行されることは保証されません。

ISAは、命令や他の機能を追加したり、より大きなアドレスやデータ値のサポートを追加することで拡張することができます。拡張されたISAの実装は、拡張されていないISAのバージョンのマシンコードを実行することができます。拡張されたISAの実装は、拡張されていないISAのバージョンのマシンコードを実行することができます。拡張されたISAを使用するマシンコードは、拡張されたISAをサポートする実装上でのみ実行されます。

これらの拡張機能が提供するバイナリ互換性により、ISA はコンピューティングにおける最も基本的な抽象化の一つとなっています。

### 概要

命令セット・アーキテクチャは、マイクロアーキテクチャとは区別され、マイクロアーキテクチャは、特定のプロセッサで命令セットを実装するために使用されるプロセッサ設計技術のセットです。異なるマイクロアーキテクチャを持つプロセッサは、共通の命令セットを共有することができます。例えば、Intel Pentium と Advanced Micro Devices Athlon は、ほぼ同じバージョンの x86 命令セットを実装していますが、内部設計は全く異なります。

特定のマシンの設計とは異なるアーキテクチャの概念は、IBMのフレッド・ブルックスがSystem/360の設計段階で開発したものです。
NPL [System/360]以前は、IBMのコンピュータ設計者は、技術を選択するだけでなく、機能やアーキテクチャを改良することで、自由にコスト目標を達成していました。対照的に、SPREAD互換性目標では、コストと性能の広い範囲に渡る5つのプロセッサのシリーズに対して、単一のアーキテクチャを想定していました。5つの技術設計チームのいずれも、コストと性能の目標達成の困難さを緩和する方法として、アーキテクチャの仕様を調整することができるかどうかはあてにならなかった:p.137

Java 仮想マシンの Smalltalk や Microsoft の Common Language Runtime など、バイトコードを ISA としてサポートしているいくつかの仮想マシンでは、一般的に使用されるコードパスのバイトコードをネイティブマシンのコードに変換することでこれを実装しています。さらに、これらの仮想マシンは、あまり頻繁に使用されないコードパスを解釈して実行します（参照：ジャストインタイムコンパイル）。Transmeta は、VLIW プロセッサの上に x86 命令セットをこの方法で実装しました。



### ISAの分類

ISAは、いくつかの異なる方法で分類されることがあります。一般的な分類は、アーキテクチャの複雑さによるものです。複雑な命令セットコンピュータ(CISC)は、多くの特殊な命令を持ち、その中には実用的なプログラムではほとんど使用されない命令も含まれています。縮小命令セットコンピュータ(RISC)は、プログラムで頻繁に使用される命令のみを効率的に実装することでプロセッサを簡素化し、あまり一般的ではない操作はサブルーチンとして実装され、その結果として生じる追加のプロセッサ実行時間を使用頻度が低いことで相殺している。

その他のタイプとしては、非常に長い命令語(VLIW)アーキテクチャや、密接に関連する長い命令語(LIW)アーキテクチャ、明示的並列命令コンピューティング(EPIC)アーキテクチャなどがあります。これらのアーキテクチャは、命令の発行とスケジューリングをコンパイラに任せることで、RISCやCISCよりも少ないハードウェアで命令レベルの並列性を利用しようとしています。

また、MISC(Minimal Instruction Set Computer)やOISC(One Instruction Set Computer)のように、さらに複雑さを抑えたアーキテクチャも研究されています。これらは理論的には重要なタイプであるが、実用化されていない。



## von Neumann architecture

[Von_Neumann_architecture(en.wikipedia)](https://en.wikipedia.org/wiki/Von_Neumann_architecture)

フォン・ノイマン・アーキテクチャ（フォン・ノイマン・モデル、プリンストン・アーキテクチャとも呼ばれる）は、ハンガリー系アメリカ人の数学者で物理学者のジョン・フォン・ノイマンらが1945年に発表した「EDVACに関する報告書の第1次草案」に基づいたコンピュータ・アーキテクチャです。この文書では、これらの構成要素を持つ電子デジタルコンピュータの設計アーキテクチャが記述されています。

- 算術論理ユニットとプロセッサレジスタを含む処理ユニット
- 命令レジスタとプログラムカウンタを内蔵した制御装置
- データや命令を記憶するメモリ
- 外部マスストレージ
- 入出力機構

「フォン・ノイマン・アーキテクチャ」という用語は、共通のバスを共有しているため、命令のフェッチとデータ操作が同時に発生しないストアド・プログラム・コンピュータを意味するように発展してきました。これは、フォン・ノイマン・ボトルネックと呼ばれ、しばしばシステムの性能を制限します。

フォン・ノイマン・アーキテクチャー・マシンの設計は、ハーバード・アーキテクチャー・マシン（ストアド・プログラム・システムでもあるが、メモリへの読み書きのための専用のアドレス・データ・バスと、命令を取得するための別のアドレス・データ・バスのセットを持つ）よりも単純である。

ストアド・プログラム・デジタル・コンピュータは、プログラム命令とデータの両方を読み書き可能なランダム・アクセス・メモリ（RAM）に保存します。ストアドプログラムコンピュータは、1940年代のコロッサスやENIACなどのプログラム制御型コンピュータよりも進歩したものです。これらのコンピュータは、様々な機能ユニット間でデータや制御信号をルーティングするために、スイッチを設定したり、パッチケーブルを挿入したりすることでプログラムされていました。現代のコンピュータの大部分は、データとプログラム命令の両方に同じメモリを使用しています。フォン・ノイマンとハーバードの区別は、メインメモリ（分割キャッシュアーキテクチャ）ではなく、キャッシュアーキテクチャに適用されます。

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/Von_Neumann_Architecture.svg/2880px-Von_Neumann_Architecture.svg.png)



### 歴史

初期のコンピュータは固定プログラムを持っていました。非常にシンプルなコンピュータの中には、今でもシンプルさやトレーニング目的のためにこの設計を採用しているものもあります。例えば、机上電卓は（原理的には）固定プログラムコンピュータです。基本的な数学はできますが、ワープロやゲームはできません。固定プログラムのマシンのプログラムを変更するには、マシンの再配線、再構築、再設計が必要です。初期のコンピュータは、特定のタスクのために「設計された」というほど「プログラムされた」ものではありませんでした。"再プログラム "は、可能な場合には、フローチャートや紙のメモから始まり、詳細なエンジニアリング設計、そして物理的にマシンを再配線して再構築するという手間のかかるプロセスを経て行われていました。ENIAC上でのプログラムのセットアップとデバッグには3週間かかることもありました。

ストアドプログラムコンピュータの提案で、これは変わりました。ストアドプログラムコンピュータは、設計上、命令セットを含み、計算を詳述する命令セット（プログラム）をメモリに格納することができる。

また、ストアドプログラム設計では、コードを自己修正することも可能です。このような機能の初期の動機の1つは、初期の設計では演算子が手動で行わなければならなかった命令のアドレス部分のインクリメントや修正をプログラムで行う必要があったことです。インデックスレジスタや間接アドレッシングがマシンアーキテクチャの通常の機能になってからは、この機能の重要性は低くなりました。もう一つの用途は、即時アドレッシングを使用して命令ストリームに頻繁に使用されるデータを埋め込むことでした。自己修正コードは通常、理解やデバッグが難しく、現代のプロセッサのパイプライン化やキャッシングスキームでは非効率的であるため、現在ではほとんどの場合、好まれなくなっています。



### 機能

大規模では、命令をデータとして扱うことができるからこそ、アセンブラ、コンパイラ、リンカ、ローダなどの自動化プログラミングツールが可能になる。プログラムを書くプログラム」を可能にしているのです。これにより、フォン・ノイマン・アーキテクチャのマシンを中心に、洗練されたセルフホスティング・コンピューティングのエコシステムが花開いている。

いくつかの高レベル言語は、実行時に実行コードを操作するための抽象的でマシンに依存しない方法を提供したり（LISPなど）、実行時の情報を利用してジャストインタイムのコンパイルを調整したりすることで、フォン・ノイマン・アーキテクチャを活用しています（Java仮想マシン上でホストされている言語や、Webブラウザに組み込まれている言語など）。

より小さな規模では、BITBLTやピクセルシェーダや頂点シェーダのようないくつかの反復的な操作は、汎用プロセッサ上でジャストインタイムコンパイル技術を用いて高速化することができます。これは、人気のある自己修正コードの1つの用途です。



### Development of the stored-program concept

ケンブリッジ大学のマックス・ニューマンの講義によって数学的論理学の問題に警鐘を鳴らした数学者アラン・チューリングは、1936年に「On Computable Numbers, with an Application to the Entscheidungsproblem」と題する論文を書き、ロンドン数学会の議事録に掲載されました。その中で彼は、現在「ユニバーサル・チューリング・マシン」として知られているユニバーサル・コンピューティング・マシンと呼ばれる仮想マシンについて述べています。この仮想マシンは、命令とデータの両方を含む無限のストア（今日の用語ではメモリ）を持っていた。ジョン・フォン・ノイマンがチューリングと知り合ったのは、1935年にケンブリッジ大学の客員教授をしていた時、また1936年から1937年にかけてニュージャージー州プリンストンの高等研究所でチューリングの博士号を取得していた時でした。その時にチューリングの1936年の論文を知っていたかどうかは明らかではありません。

1936年には、コンラッド・ズースも2つの特許出願で、機械の命令がデータに使われているのと同じストレージに格納されることを予想していた。

独立して、ペンシルバニア大学のムーア電気工学部でENIACを開発していたJ Presper EckertとJohn Mauchlyは、1943年12月にストアドプログラムの概念について書いています。エッカートは新機械EDVACを計画するにあたり、1944年1月に、新しいアドレス可能な記憶装置である水銀金属遅延線メモリにデータとプログラムを格納すると書いている。これが、実用的なストアドプログラムマシンの建設が提案された初めてのことであった。この時、彼とモーチュリーはチューリングの研究を知らなかった。

フォン・ノイマンはロスアラモス国立研究所のマンハッタン計画に関わっていたが、この計画では膨大な計算が必要であった。これが、1944年の夏、彼をENIACプロジェクトに引き寄せました。そこで彼は、この保存プログラムコンピュータEDVACの設計に関する継続的な議論に参加しました。このグループの一員として、彼はEckertとMauchlyの研究に基づいたEDVACに関する報告書の第一稿というタイトルの記述を書き上げた。彼の同僚のハーマン・ゴールドスタインがフォン・ノイマンの名前だけを載せてそれを回覧したときには未完成でしたが、エッカートとモーチュリーは大騒ぎになりました。この論文はアメリカとヨーロッパの何十人ものフォン・ノイマンの同僚に読まれ、次のコンピュータ設計に影響を与えました。



ジャック・コープランドは、「電子的に記憶されたプログラムのデジタル・コンピュータを「フォン・ノイマン・マシン」と呼ぶことは、歴史的に不適切である」と考えています。

 彼のロスアラモスの同僚であるスタン・フランケルは、フォン・ノイマンがチューリングのアイデアを尊重していたことについて次のように述べています。

私は、1943年か44年頃にフォン・ノイマンが1936年のチューリングの論文の根本的な重要性を十分に認識していたことを知っています...フォン・ノイマンは私にその論文を紹介してくれました。多くの人がフォン・ノイマンを「コンピュータの父」(現代的な意味での)と称賛していますが、私は彼自身がそのような過ちを犯すことはなかったと確信しています。彼は助産師と呼ばれているかもしれませんが、私や他の人たちには、基本的な概念はバベッジが予想していなかった限りにおいてチューリングによるものであることをしっかりと強調していました...もちろんチューリングとフォン・ノイマンは、これらの概念の「実践への還元」にもかなりの貢献をしましたが、私はこれらを、活動のプログラムをメモリに保存し、活動の過程でそのプログラムを修正することができるコンピュータの概念の導入と説明に匹敵する重要性とは考えていません。

第一草案」報告書が配布された当時、チューリングは「提案された電子計算機」と題する報告書を作成していました。それには、自動計算エンジン(ACE)と呼ばれる機械のアイデアが工学的にもプログラミング的にも詳細に記述されていました。彼はこれを1946年2月19日に英国国立物理研究所の執行委員会に提出しました。チューリングは戦時中のブレッチリー・パークでの経験から、彼が提案したものが実現可能であることを知っていましたが、その後数十年間維持されたコロッサスを取り巻く秘密が、彼がそう言うことを妨げていました。ACE設計の様々な成功した実装が生産されました。

フォン・ノイマンとチューリングの論文は両方とも保存プログラムコンピュータを記述していますが、フォン・ノイマンの初期の論文の方がより多くの流通を達成し、それが説明したコンピュータアーキテクチャは「フォン・ノイマン・アーキテクチャ」として知られるようになりました。1953年の出版物『Faster than Thought. A Symposium on Digital Computing Machines (Edit by B. V. Bowden)では、アメリカのコンピュータの章の一節は次のように書かれています。

**プリンストン高等研究所の機械**

>  1945年、E.N.I.A.C.が建設されたフィラデルフィアのムーア工科大学で働いていたJ.フォン・ノイマン教授は、同僚のグループを代表してデジタルコンピュータの論理設計に関する報告書を発表しました。その報告書には、後にE.D.V.A.C.（電子離散可変自動計算機）として知られるようになった機械の設計に関する詳細な提案が含まれていました。この機械はアメリカでは最近完成したばかりですが、フォン・ノイマンの報告書に触発されてケンブリッジにE.D.S.A.C.（電子遅延記憶式自動計算機）が建設されました（130ページ参照）。

> 1947年、バークス、ゴールドスタイン、フォン・ノイマンは、別のタイプの機械（今回は並列計算機）の設計の概要をまとめた報告書を発表しました。彼らは、そのようなマシンを構築する上での顕著な問題は、瞬時にアクセスできる内容を持つ適切なメモリの開発であると指摘した。最初に彼らが提案したのは、RCAのプリンストン研究所が発明した「セレクトロン」と呼ばれる特殊な真空管を使うことだった。この真空管は高価で作るのが難しかったため、フォン・ノイマンはその後、ウィリアムズのメモリをベースにした機械を作ることにした。この機械は1952年6月にプリンストンで完成し、「マニアック」として広く知られるようになりました。この機械のデザインは、現在アメリカで製造されている少なくとも6台の機械にインスピレーションを与え、「ジョニアック」という愛称で親しまれています。

同じ本の中で、ACEの章の最初の2段落は次のように読まれています。

**国立物理学研究所における自動計算**

> 自動電子計算技術の開発と改良を具現化した最も近代的なデジタルコンピュータの一つが、最近、国立物理研究所のテッディングトンで実演されました。これまでのところ研究所に設置されている装置は、自動計算エンジンとして知られているもっと大きな装置のパイロットモデルに過ぎませんが、プレートXII、XIII、XIVから判断できるように、比較的小型で、約800個の熱電対を含むだけですが、非常に高速で汎用性の高い計算機であることがわかります。

>  機械による計算の基本的な概念と抽象的な原理は、A.M.チューリング博士（F.R.S.）によって、1936年にロンドン数学会の前で読まれた論文1.で定式化されましたが、イギリスでのそのような機械の研究は戦争のために遅れていました。しかし、1945年に、問題の調査は、国立物理研究所で、当時研究所の数学部門の最高責任者であったJ.R.ウォーマスリー氏によって行われました。彼にはチューリング博士と少数の専門家スタッフが加わり、1947年までには予備的な計画が十分に進み、先に述べた特別なグループの設立を正当化することができました。1948年4月、後者はF.M.コールブルック氏の指揮の下、研究所の電子部門となりました。



### 進化

1960 年代から 1970 年代にかけて、コンピュータは一般的に小型化と高速化の両方を実現し、アーキテクチャの進化につながりました。例えば、メモリマップされたI/Oでは、入力デバイスと出力デバイスをメモリと同じように扱うことができます。単一のシステムバスを使用することで、低コストでモジュラーシステムを提供することができました[解明が必要]。これは、アーキテクチャの「合理化」と呼ばれることもあります。その後の数十年で、単純なマイクロコントローラは、コストとサイズを下げるためにモデルの機能を省略することもあった。より大きなコンピュータでは、高性能化のために機能が追加された。



### フォンノイマンボトルネック

プログラムメモリとデータメモリの間の共有バスは、中央処理装置（CPU）とメモリの間のスループット（データ転送レート）がメモリの量に比べて制限されるという、フォン・ノイマン・ボトルネックにつながる。単一バスは、一度に2つのクラスのメモリのうちの1つにしかアクセスできないため、スループットは、CPUが作業できる速度よりも低くなります。これは、CPUが大量のデータに対して最小限の処理を行う必要がある場合の実効処理速度を著しく制限します。ＣＰＵは、必要なデータがメモリに移動したり、メモリから移動したりするのを絶えず待たなければならない。CPUの速度とメモリサイズは、それらの間のスループットよりもはるかに速くなっているため、ボトルネックは、新世代のCPUが登場するたびに深刻さを増していく問題となっています。

フォン・ノイマンのボトルネックは、ジョン・バックウスが1977年のACMチューリング賞の講演で説明している。Backusによると

確かに、フォン・ノイマン・ボトルネックを通って膨大な数の言葉を前後に押すよりも、ストアの中で大きな変化を起こすためには、もっと原始的な方法があるはずです。このボトルネックは、問題のデータトラフィックの文字通りのボトルネックであるだけでなく、もっと重要なのは、私たちが目の前のタスクのより大きな概念的な単位で考えることを奨励する代わりに、単語単位の思考に縛られ続けてきた知的なボトルネックでもあるということです。このように、プログラミングは基本的には、フォン・ノイマンのボトルネックを通る膨大な言葉のトラフィックを計画し、詳細に記述することであり、そのトラフィックの多くは、重要なデータそのものではなく、どこでそれを見つけるかに関係しているのです。



### On Computable Numbers, with an Application to the Entscheidungsproblem

https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf

"計算可能"数とは、10進数としての式が有限の手段で計算可能な実数を簡単に説明することができます。

本論文の主題は表向きは計算可能数であるが，積分変数や実数・計算可能変数の計算可能関数，計算可能述語などを定義して調べることはほぼ同様に容易である．しかし，基本的な問題はそれぞれのケースで同じであり，私は，最も面倒な技術を必要としないものとして，計算可能数を明示的に扱うことにしました．近いうちに、計算可能数や関数などの関係を説明したいと思っています。これには，計算可能数で表現された実数変数の関数の理論を発展させることも含まれます．私の定義によると，計算可能な数は，その10進数が機械で書き留められる場合に計算可能である．



### *Entscheidungsproblem*

[Entscheidungsproblem(en.wikipedia)](https://en.wikipedia.org/wiki/Entscheidungsproblem)

数学とコンピュータサイエンスでは、エンツァイトシャイトungsproblem（発音[ɛntˈʃaɪ̯dʊŋspʁoˌbleːm]、"決定問題 "のためのドイツ語）は、1928年にデビッド・ヒルベルトとヴィルヘルム・アッカーマンによって提起された課題です。問題は、文が普遍的に有効であるかどうかに応じて、入力として、文と答え "はい "または "いいえ "を考慮したアルゴリズムを求めている、すなわち、公理を満たすすべての構造で有効です。



### *First Draft of a Report on the EDVAC*

EDVACに関する報告書の第一稿（一般的には第一稿と短縮される）は、ジョン・フォン・ノイマンによって書かれた101ページの不完全な文書で、1945年6月30日に機密扱いのENIACプロジェクトのセキュリティオフィサーであったハーマン・ゴールドスタインによって配布されました。この文書には、保存プログラムの概念を使用したコンピュータの論理設計の最初の公開された記述が含まれており、物議を醸してフォン・ノイマン・アーキテクチャとして知られるようになりました。

#### 歴史

フォン・ノイマンは、ニューメキシコ州ロスアラモスに電車で通勤中に手書きで報告書を書き、その手書きのメモをフィラデルフィアに郵送しました。ゴールドスタインはその報告書をタイプして複製した。タイプされた報告書の日付は6月30日ですが、その5日前の6月25日には24部の第一草案がEDVACプロジェクトの関係者に配布されています。ケンブリッジ大学のモーリス・ウィルクスは、この報告書の内容に興奮したことが、1946 年夏にムーア・スクールの講義のために渡米することを決めたきっかけになったと述べています。



#### あらすじ

フォン・ノイマンは、"非常に高速な自動デジタル計算システム "の詳細な設計を説明しています。彼はそれを6つの主要な細分化に分けています：中央演算部、CA、中央制御部、CC、メモリ、M、入力、I、出力、O、および（低速の）外部メモリ、R、例えばパンチカード、テレタイプテープ、または磁気ワイヤーやスチールテープなどです。

ＣＡは、足し算、引き算、掛け算、割り算、平方根を行う。他の数学的操作、例えば対数や三角関数は、テーブルルックアップと補間、場合によっては二乗法で行うことになっています。彼は乗算と除算は、対数テーブルで行うことができることに注意してくださいが、テーブルを十分に小さく保つために、補間が必要とされるだろうし、これは順番に乗算を必要とするが、おそらくより少ない精度で。

数字は二進法で表現されます。彼は27桁の2進数（彼は1948年にクロード・シャノンによって造語された「ビット」という言葉を使わなかった）で十分であろうと推定しています（小数点以下8桁の精度が得られます）が、符号ビットと次数と数字を区別するためのビットで30ビットの数字を丸めて、彼がマイナーサイクルと呼ぶ32ビットの単語をもたらします。2の補数演算を使用し、減算を単純化します。乗算と除算については、符号ビットの後に2進数を置くことを提案しています。これは、すべての数値が-1と+1の間にあるものとして扱われることを意味します。



#### 回路設計

真空管はリレーではなく、リレーのための10ミリ秒に対して1マイクロ秒で動作する能力のために使用されるべきである。

フォン・ノイマンは（項5.6）コンピュータを可能な限りシンプルに保ち、演算の重複による性能向上の試みを避けることを提案しています。算術演算は、2進数を一度に1桁ずつ実行することになっています。彼は、2つの2進数の足し算には1マイクロ秒かかると見積もっています。したがって、30ビットの乗算には約302マイクロ秒、つまり約1ミリ秒かかることになります。

フォン・ノイマンの設計は、彼が「E素子」と呼ぶものを使って構築されていますが、これは生物学的ニューロンをモデルにしていますが、1本または2本の真空管を使って構築できると彼が言うデジタルデバイスです。現代用語では、彼の最も単純なE素子は、1つの入力を反転させた2つの入力ANDゲート（インヒビット入力）である。より多くの入力を持つE素子は、関連するスレッショルドを持ち、正の入力信号の数がスレッショルドを満たすか、または超えたときに出力を生成します。彼は、より多くの入力を持つE素子は最も単純なバージョンから構築できると述べていますが、必要とされる真空管の数が少なくなるため、真空管回路として直接構築することを提案しています。

より複雑な機能ブロックは、これらのE素子から構築することになります。彼は、これらのE要素を使って、足し算、引き算、乗算、除算、平方根の回路、2つの状態記憶ブロックと制御回路を構築する方法を示しています。ブール論理学の用語は使いません。

回路は、真空管発振器から派生したマスターシステムクロックと同期しており、場合によっては水晶で制御されることもあります。同期設計では時間遅延を考慮しなければならないため、彼の論理図には単位時間遅延を表す矢印記号が含まれています。彼は、1マイクロ秒で電気パルスが300メートル移動することを指摘していますが、これは、より高いクロック速度、例えば毎秒108サイクル（100MHz）までは、ワイヤの長さが問題にならないことを示しています。

誤差検出と補正の必要性については言及されていますが、詳しくは述べられていません。



#### メモリ設計

後にフォン・ノイマン・アーキテクチャと呼ばれるようになった重要な設計コンセプトは、数字（データ）と命令（命令）の両方を含む統一されたメモリです。

"デバイスはかなりのメモリを必要とします。このメモリの様々な部分が、その性質や目的が大きく異なる機能を実行しなければならないように見えましたが、それにもかかわらず、メモリ全体を一つの器官として扱い、上で列挙した様々な機能のために、その部分を可能な限り交換可能にしておくことは魅力的です。" (第2.5節)

"CCによって受け取られる命令はMから、すなわち数値的な材料が格納されているのと同じ場所から来る。" (Sec.14.0) (Sec.14.0)

フォン・ノイマンは、常微分方程式と偏微分方程式、ソート、確率実験を含むいくつかのクラスの数学的問題に基づいて、必要なメモリの量を推定している。これらのうち、2次元＋時間の偏微分方程式が最も多くのメモリを必要とし、3次元＋時間は当時利用可能だった技術では不可能なことです。彼は、メモリがシステムの最大の細分化になると結論づけ、設計目標として32ビットの8,192マイナーサイクル（ワード）を提案し、2,048マイナーサイクルはまだ有用であるとしています。彼は、プログラムを格納するためには数百マイナーサイクルで十分だと見積もっている。

彼は2種類の高速メモリ、遅延線とIconoscope tubeを提案している。各マイナーサイクルは単位としてアドレス指定されます(ワードアドレス指定、項12.8)。命令は順次実行され、メモリ内の別のポイントに切り替えるための特別な命令(すなわちジャンプ命令)がある。

遅延ラインメモリ内の2進数は、ラインを通過して先頭にフィードバックされます。遅延ライン内のデータにアクセスすると、目的のデータが再び回ってくるのを待っている間、時間的なペナルティが発生する。これらのタイミングの問題を分析した後、彼は遅延線メモリを256個の遅延線「器官」（DLA）に整理することを提案しています。メモリアクセスは、まずDLA(8ビット)を選択し、次にDLA内のマイナーサイクル(5ビット)を選択します。

Iconoscopeのメモリについては、管面上の各スキャンポイントがコンデンサであり、1つのコンデンサが1ビットを格納できることを認識している。非常に高精度なスキャンが必要となり、メモリの寿命は1秒程度と短く、定期的な再コピー（リフレッシュ）が必要となります。

#### Order (Instruction)

Sec 14.1では、フォン・ノイマンは次数の形式を提案していますが、これを彼はコードと呼んでいます。オーダータイプには、基本的な算術演算、CAとMの間のマイナーサイクルの移動（現代用語ではワードのロードとストア）、前の演算の符号に基づいて2つの数値のうちの1つを選択するオーダー(s)、入力と出力、CCを別の場所の記憶場所に転送するオーダー(ジャンプ)が含まれます。彼は、異なるオーダータイプに必要なビット数を決定し、次のワードがオペランドである即時オーダーを提案し、将来的により多くのアドレス指定可能なメモリを可能にするために、オーダーフォーマットに予備ビットを残すことの望ましさや、その他の不特定多数の目的について議論しています。マイナーサイクルに2つ以上のオーダーを格納する可能性が議論されていますが、そのアプローチにはあまり熱心ではありません。次数の表は提供されているが、入出力命令についての議論は第一次ドラフトには含まれていない。



## Universal Turing machine

[Universal_Turing_machine(en.wikipedia)](https://en.wikipedia.org/wiki/Universal_Turing_machine)

コンピュータ・サイエンスでは、ユニバーサル・チューリング・マシン(UTM)とは、任意の入力で任意のチューリング・マシンをシミュレートするチューリング・マシンのことです。ユニバーサル・チューリング・マシンは、シミュレーションされるマシンの記述と、それ自身のテープからそのマシンへの入力の両方を読み取ることによって、これを本質的に達成します。アラン・チューリングは1936-1937年にそのような機械のアイデアを導入しました。この原理は、1946年にジョン・フォン・ノイマンが現在のフォン・ノイマンの名を冠した「電子計算機」のために使用したストアド・プログラム・コンピュータのアイデアの起源であると考えられています：フォン・ノイマン・アーキテクチャ。

計算の複雑さという点では、マルチテープ・ユニバーサル・チューリング・マシンは、シミュレーションするマシンと比較して対数的に遅くなるだけでよいのです。

### Introduction

すべてのチューリングマシンは、そのアルファベット上の入力文字列から、ある固定された部分的な計算可能な関数を計算します。その意味では、それは固定されたプログラムを持つコンピュータのように振る舞います。しかし、どんなチューリング・マシンの動作表も文字列でエンコードすることができます。このようにして、動作表を記述した文字列と入力テープを記述した文字列をテープに期待し、エンコードされたチューリング・マシンが計算したであろうテープを計算するチューリング・マシンを構築することができます。チューリングは1936年の論文でそのような構造を完全に詳細に記述しています。

"どんな計算可能なシーケンスでも計算するために使われる単一の機械を発明することが可能です。もしこの機械Uが、ある計算機MのS.D [アクション・テーブルの "標準記述 "が書かれたテープと一緒に供給されるならば、UはMと同じシーケンスを計算するでしょう。



### Stored-program computer

ストアドプログラムコンピュータ
デイヴィスは、現在「ストアド・プログラム・コンピュータ」として知られているチューリングの「アクション・テーブル」（機械のための命令）を入力データと同じ「メモリ」に置くという概念が、ジョン・フォン・ノイマンの最初のアメリカの離散記号（アナログではなく）コンピュータであるEDVACの概念に強く影響を与えたという説得力のある議論を展開しています。デイヴィスは、「キーボードを叩く人は誰でも...チューリング・マシンの化身で作業している」、「ジョン・フォン・ノイマンはアラン・チューリングの仕事の上に構築した」(Davis 2000:193、1999年3月29日のTime誌を引用)と、このような効果があるとTime誌を引用しています。

Davisは、チューリングの自動計算エンジン(ACE)コンピュータがマイクロプログラミング(マイクロコード)とRISCプロセッサの概念を「先取りした」と主張しています(Davis 2000:188)。クヌースは、ACEコンピュータにおけるチューリングの仕事を、「サブルーチンのリンケージを容易にするハードウェア」を設計したものとして引用しています(クヌース1973:225)。

チューリング・マシンがコンピュータの構築を奨励していたように、UTMは駆け出しのコンピュータ科学の発展を奨励していました。最初とは言わないまでも、初期のアセンブラは、EDVACのために「若くて優秀なプログラマーによって」提案されました(Davis 2000:192)。フォン・ノイマンの「最初の本格的なプログラムは それは単にデータを効率的にソートすることでした」(Davis 2000:184)。Knuthは、特別なレジスタではなくプログラム自体にサブルーチンリターンが埋め込まれているのは、フォン・ノイマンとゴールドスタインに起因すると観察している。 Knuthはさらに次のように述べている。

"最初の解釈ルーチンは、"ユニバーサルチューリングマシン "であると言われるかもしれません... 従来の意味での解釈ルーチンは、1946年のムーア・スクールでの講義でジョン・モーチュリーによって言及されました... チューリングはこの開発にも参加しました; Pilot ACEコンピュータのための解釈システムは彼の指示のもとに書かれました」(Knuth 1973:226)。
Davisはプログラム・アズ・データという概念の成果としてオペレーティングシステムとコンパイラについて簡単に言及しています(Davis 2000:185)。

しかし、この評価には問題があるかもしれません。当時(40年代半ばから50年代半ば)、比較的少数の研究者が新しい「デジタルコンピュータ」のアーキテクチャに密接に関わっていました。この頃の若い研究者であるハオ・ワン（Hao Wang, 1954）は、次のような観察をしています。

チューリングの計算可能な関数の理論は前からあったが、実際のデジタルコンピュータの広範な構築にはあまり影響を与えていない。理論と実践のこの二つの側面は、ほぼ完全に独立して発展してきた。主な理由は、論理学者が応用数学者や電気技術者が主に関心を持っている問題とは根本的に異なる問題に関心を持っているからであることは間違いありません。しかし、同じ概念が二つの発展の中で全く異なる用語で表現されることがしばしばあるのが不思議でならないわけではありません」(Wang 1954, 1957:63)。(Wang 1954, 1957:63)
王は、彼の論文が「2つのアプローチを結びつける」ことを望んでいた。実際、Minskyはこれを確認している。"コンピュータのようなモデルにおけるチューリングマシン理論の最初の定式化はWang(1957)に現れています」(Minsky 1967:200)。ミンスキーは、カウンターマシンのチューリング等価性を実証するために進みます。

コンピュータを単純なチューリング等価モデルに還元することに関しては（またその逆も）、「最初の定式化」を行ったのはWangであるというMinskyの指定は議論の余地があります。ミンスキーの1961年の論文と王の1957年の論文は、ShepherdsonとSturgis (1963)によって引用されていますが、彼らはまた、ヨーロッパの数学者Kaphenst (1959)、Ershov (1959)、Péter (1958)の研究を詳細に引用し、要約しています。Sheperdson-Sturgis (1963)とElgot-Robinson (1961)の書誌には、Hermes (1954, 1955, 1961)とKaphenst (1959)の名前が掲載されています。重要な他の2人の名前は、カナダの研究者Melzak (1961)とLambek (1961)です。詳細については、チューリングマシンの等価物を参照してください。



## Turing machine

[Turing_machine(en.wikipedia)](https://en.wikipedia.org/wiki/Turing_machine)

チューリング・マシンは、抽象的な機械を定義した計算の数学モデルであり、ルールの表に従ってテープの上のシンボルを操作します。このモデルの単純さにもかかわらず、任意のコンピュータ・アルゴリズムが与えられ、そのアルゴリズムの論理をシミュレートすることができるチューリング・マシンを構築することができます。

マシンは、離散的な「セル」に分割された無限のメモリ・テープ上で動作します。マシンはその「頭」をセルの上に置き、そこにあるシンボルを「読み取る」か「スキャンする」。次に、シンボルとユーザが指定した命令の「有限のテーブル」の中の現在の位置に従って、マシンは(i)セルにシンボル(例えば、有限のアルファベットからの数字や文字)を書きます(いくつかのモデルでは、シンボルの消去や書き込みなしを許可しています)。

チューリングマシンは、1936年にアラン・チューリングによって発明され、彼はこれを「a-machine」（自動機械）と呼んだ。このモデルで、チューリングは2つの疑問に否定的に答えることができました。(1) テープ上の任意の機械が「円形」であるかどうかを判断できる機械は存在するのか(例えば、フリーズするか、計算タスクを継続するのに失敗するか)、同様に、(2) テープ上の任意の機械が与えられた記号を印刷するかどうかを判断できる機械は存在するのか。このようにして、任意の計算が可能な非常に単純な装置の数学的記述を提供することによって、彼は計算一般の性質を証明し、特にエンツシャイトungsproblem（「決定問題」）の計算不可能性を証明することができました。

このように、チューリング・マシンは、機械的計算の力の根本的な限界を証明しています。実世界のコンピュータは、チューリング・マシンとは異なり、ランダム・アクセス・メモリを使用する異なる設計に基づいています。

チューリング完全性とは、ある命令システムがチューリング・マシンをシミュレートする能力のことです。チューリング完全性を持つプログラミング言語は、理論的にはコンピュータが達成可能なすべてのタスクを表現することができます。



### Overview

チューリングマシンは、コンピュータが行うすべてのデータ操作を制御する中央処理装置(CPU)の一般的な例であり、定型的なマシンはシーケンシャルメモリを使用してデータを保存します。より具体的には、それはアルファベットの有効な文字列の任意のサブセットを列挙することができるマシン（オートマトン）であり、これらの文字列は再帰的に列挙可能なセットの一部です。これらの文字列は、再帰的に列挙可能な集合の一部です。チューリング・マシンは、無限の長さのテープを持っていて、そこに読み書き操作を行うことができます。

ブラックボックスを仮定すると、チューリング・マシンは、与えられたプログラムで部分集合の特定の文字列を最終的に列挙するかどうかを知ることができません。これは、停止問題が解けないという事実に起因しており、これはコンピューティングの理論的限界に大きな意味を持っています。

チューリング・マシンは無制限の文法を処理することができますが、これはさらに、無限の方法で一次論理をロバストに評価することができることを意味します。これはラムダ計算で有名です。

他のチューリングマシンをシミュレートできるチューリングマシンは、ユニバーサルチューリングマシン（UTM、または単にユニバーサルマシン）と呼ばれています。同じような「普遍的」な性質を持つ、より数学的に指向された定義は、アロンゾ・チャーチによって導入されました。彼のラムダ微積分の研究は、チャーチ・チューリング論文として知られる計算の形式的理論でチューリングと絡み合っていました。この論文では、チューリング・マシンは実際に論理学や数学における有効な方法の非公式な概念を捉えており、アルゴリズムや「機械的な手続き」の正確な定義を提供していると述べています。その抽象的な性質を研究することで、計算機科学や複雑性理論への多くの洞察が得られます。

物理的な説明
1948年のエッセイ「知能機械」の中で、チューリングは彼の機械が構成されていると書いています

...正方形にマークされた無限のテープの形で得られた無制限の記憶容量は、それぞれのシンボルを印刷することができます。どんな時でも、機械の中には一つの記号があります; それはスキャンされた記号と呼ばれます。マシンはスキャンされたシンボルを変更することができ、その動作はそのシンボルによって部分的に決定されますが、他の場所にあるテープ上のシンボルはマシンの動作に影響を与えません。しかし、テープは機械を通って前後に移動させることができ、これは機械の基本的な操作の一つである。テープ上の任意のシンボルは、したがって、最終的にはイニングを持つことができる。

- Turing 1948, p.3



### Turing machine gallery

[Turing_machine_gallery(en.wikipedia)](https://en.wikipedia.org/wiki/Turing_machine_gallery)



#### チューリングマシンの芸術的表現

![img](https://upload.wikimedia.org/wikipedia/commons/3/3d/Maquina.png)



#### Turing machine as a mechanical device

ここに示されているチューリング・マシンは、「タリー・マーク」と書かれているだけでなく、消すこともできる特殊な紙テープで構成されています。おそらくTABLEは、同じような「読み取り専用」の紙テープリーダーで作られているか、あるいはパンチングされたカードを読み取るのでしょう。チューリングの伝記作家アンドリュー・ホッジス(1983)は、子供の頃のチューリングはタイプライターが好きだったと書いています。奇跡的な機械」--ヒルベルトの決定問題に取り組むことができる機械的なプロセス」(Hodges p. 98)は、チューリングの教師の一人であるG.H.ハーディによって提案されていました。それにもかかわらず、「彼の機械は1936年に存在していたものの中には、テレプリント機、テレビの「スキャニング」、自動電話交換機の接続などの新しい電気産業の一般的な用語を除いて、明らかなモデルを持っていませんでした。それは彼自身の発明であった。(Hodges p. 109)

Davis (2000)によると、チューリングは電気機械式リレーから二進数乗算器を作ったそうです(p.170)。アルゴリズムの歴史の項で述べたように、1930年代には、パンチングされた紙テープや印刷された紙のテープ、パンチングされた紙のカードが一般的でした。

Boolos と Jeffrey (1974, 1999) は、「ある状態または別の状態にあるということは、ある歯車の歯車が一番上にあるということかもしれない」(p.21)と記しています。(p. 21).

![Turing machine 1.JPG](https://upload.wikimedia.org/wikipedia/en/b/bb/Turing_machine_1.JPG)



### A robot carries out the instructions

このモデルは、Stone (1972)によって提案された。

"コンピュータとは、一連の命令として記述できるあらゆるタスクを実行するロボットであるという視点を採用しよう」(p. 3)。
ストーンは、アルゴリズムの概念を発展させるためにロボットを使用しています。このことは、チューリング・マシンの記述と彼の発言につながります。

"もし[チャーチのテーゼ]が本当ならば、チューリングマシンは非常に原始的な操作で、他のデバイスがどれだけ複雑なデバイスを選 択しても、他のデバイスが実行できるあらゆる計算を実行できることは確かに注目に値します」(p. 13)。(p. 13)

これは、2シンボル3ステートのBusy Beaverとして働くために入隊したコンソールを持つロボットです。ロボットは、最初は0/ブランクで印刷されたテープ上で作業しています。ロボットはウィンドウ内のシンボル（シンボル0）を見て、命令("状態")Cを読み、1を印刷しようとしています。 その後、テープ左ボタンを押します。最後に命令("状態")Bの方を見ます。テープがはっきりしていて、粘着性のある0を剥がして1を貼り付けてPRINTし、その逆にERASEしているのかもしれません。)

![img](https://upload.wikimedia.org/wikipedia/en/7/76/Busy_Beaver_1.JPG)



## System bus

[System_bus(en.wikipedia)](https://en.wikipedia.org/wiki/System_bus)

システムバスとは、情報を運ぶためのデータバス、送信先を決定するためのアドレスバス、動作を決定するための制御バスの機能を組み合わせて、コンピュータシステムの主要なコンポーネントを接続する単一のコンピュータバスのことです。この技術は、コスト削減とモジュール性の向上のために開発されたもので、1970年代と1980年代に人気がありましたが、現代のコンピュータでは、より特定のニーズに合わせて様々な別個のバスを使用しています。

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Computer_system_bus.svg/2880px-Computer_system_bus.svg.png)

### 背景シナリオ

計算機の多くは、1945年に発表されたEDVAC報告書の第一稿に基づいている。フォン・ノイマン・アーキテクチャとして知られるようになったものでは、中央制御ユニットと算術論理ユニット（ALU、彼は中央演算部と呼んでいた）をコンピュータ・メモリと入出力機能と組み合わせてストアド・プログラム・コンピュータを構成していた。 この報告書はコンピュータの一般的な組織と理論モデルを提示していたが、そのモデルを実装したものではなかった。 間もなく、制御ユニットとALUが中央処理装置（CPU）として知られるようになった。

1950年代と1960年代のコンピュータは、一般的にアドホックな方法で構築されていた。例えば、CPU、メモリ、および入出力ユニットは、ケーブルで接続された1つまたは複数のキャビネットであった。エンジニアは、標準化されたワイヤの束という一般的な技術を使用し、これらの初期のマシンでプリント回路基板を保持するためにバックプレーンが使用されたように、この概念を拡張しました。バス」という名称は、初期の機械式計算機を含む電気機械のさまざまな部分に電力を運ぶ「バスバー」にすでに使用されていた 。 集積回路の出現により、各コンピュータユニットのサイズが大幅に縮小され、バスはより標準化された 。 標準モジュールは、より均一な方法で相互接続でき、開発と保守がより容易になった。



## Stored-program

[Stored-program_computer(en.wikipedia)](https://en.wikipedia.org/wiki/Stored-program_computer)

ストアドプログラムコンピュータとは、プログラム命令を電子メモリに格納するコンピュータのことである。これは、プログラム命令がプラグボードまたは同様のメカニズムに格納されている機械とは対照的である。

多くの場合、この定義は、メモリ内のプログラムとデータの扱いが互換性があるか、統一されていることを条件に拡張されています。



フォン・ノイマン・アーキテクチャのコンピュータは、プログラムデータと命令データを同じメモリに格納するが、ハーバード・アーキテクチャのコンピュータは、プログラムとデータを格納するための別々のメモリを持っている。

しかし、ジャック・コープランド教授は、「電子的なストアド・プログラム・デジタル・コンピュータを『フォン・ノイマン・マシン』と呼ぶのは歴史的に不適切である」と考えています。 ヘネシーとパターソンは、初期のハーバード・マシンは「ストアド・プログラム・コンピュータの支持者からは反動的なものとみなされた」と書いています。



### 歴史

蓄積プログラムコンピュータのアイデアは、1936年に発表された万能チューリングマシンの理論的概念にまで遡ることができます。フォン・ノイマンはこの論文を知っていて、彼の共同研究者たちにもそれを印象づけました。

アタナソフ・ベリー・コンピュータのような初期のコンピュータの多くは、再プログラム可能ではありませんでした。それらは単一のハードワイヤードプログラムを実行していました。プログラム命令がないので、プログラムの保存は必要ありませんでした。他のコンピュータは、プログラム可能ではあったものの、必要に応じて機械に物理的に供給されるパンチングテープにプログラムを保存していました。

1936年、Konrad Zuseは2つの特許出願で、機械の命令をデータに使用されているのと同じストレージに保存できることを予想しました。

マンチェスター大学のBabyは、1948年6月21日に発生した、保存されたプログラムを実行する世界初の電子コンピュータとして一般的に認識されています。しかし、ベイビーは本格的なコンピュータとはみなされておらず、1949年4月に最初に研究に投入されたマンチェスター・マーク1コンピュータの前身というよりは、コンセプトを実証するためのものでした。1949年5月6日、ケンブリッジのEDSACで最初のプログラムが実行され、これはもう一つの電子デジタル・ストアド・プログラム・コンピュータとなりました。1948年1月に稼働したIBM SSECが最初のストアドプログラムコンピュータであると主張されることがありますが、この主張には賛否両論があり、特にSSECの階層的なメモリシステムのため、またリレーやテープドライブへのアクセスのように、その動作のいくつかの側面はプラグで決定されていたためです。ヨーロッパ大陸で最初に作られたストアドプログラムコンピュータは、1951年にソビエト連邦で完成したMESMでした。



## Plugboard

[Plugboard(en.wikipedia)](https://en.wikipedia.org/wiki/Plugboard)

プラグボード、またはコントロールパネル（アプリケーション領域によって使用される用語が異なります）は、電気回路を完成させるためにパッチコードを挿入することができるジャック、またはソケット（多くの場合、ハブと呼ばれる）の配列です。コントロールパネルは、いくつかのユニットレコード機器の操作を指示するために使用されました。プラグボードは、いくつかの暗号機や初期のコンピュータで使用されていました。

![Tabulator](http://www.columbia.edu/cu/computinghistory/ljc-tabulator-700.jpg)

初期の機械は、特定の用途のためにハードワイヤリングされていました。コントロールパネルは1906年にHollerith Type 1 Tabulatorに導入されました(写真はコントロールパネルを内蔵したType 3です)。1920年代には、Hollerith (IBM) の3-S型タビュレーターで取り外し可能なコントロールパネルが導入されました。これにより、アプリケーションを別のコントロールパネルに配線し、必要に応じてタビュレータに挿入することができるようになりました。リムーバブル・コントロール・パネルは、異なるアプリケーションに使用する機械の再配線が必要なすべての単位記録機に使用されるようになりました。

IBM の取り外し可能なコントロールパネルのサイズは、6 1/4" x 10 3/4" (IBM 077、IBM 550、IBM 514 などのマシンの場合) から、一辺が約 1 ～ 2 フィート (300 ～ 600 mm) のものまであり、長方形のハブが並んでいました。例えば、カードデュプリケータのアプリケーションでは、カードカラムの読み取り（発光）ハブをパンチマグネットのエントリーハブに接続することがあります。いくつかのフィールドを、おそらく別のカラムにコピーし、適切な配線によって他のカラムを無視することは比較的簡単なことでした。タビュレータのコントロールパネルは、アプリケーションによっては何十本ものパッチコードを必要とすることがありました。

タビュレータの機能は、機械部品と電気部品の両方で実装されていました。コントロールパネルは、さまざまなアプリケーションのための電気的接続の変更を簡素化したが、ほとんどのタビュレータの用途を変更するには、依然として機械的な変更が必要であった。IBM 407 は、このような機械的な変更を必要としなかった最初の IBM タビュレータで、407 の機能はすべて電気的に制御されており、アプリケーションのコントロールパネルとキャリッジテープによって完全に指定されていました。

コレータ、インタプリタからIBM 407に至るまで、コントロールパネルを備えたほとんどの機械について、IBMのマニュアルには、コントロールパネルは「指示する」、あるいは「自動操作は...によって得られた」と記述されている。IBM 602やIBM 604など、一連の操作を指定する電卓のコントロールパネルは、プログラムであると記述されていた。

**IBMのコントロールパネルは、ジャンパー線を差し込むための穴（ハブ）の開いたボードに過ぎませんでした。**

![img](https://upload.wikimedia.org/wikipedia/commons/e/ed/Man_holding_an_IBM_control_panel.ds.jpg)



#### Wiring of unit record equipment control panels

単位記録装置は、通常、着脱可能な操作パネルを用いて特定の作業を行うように構成されていた。ユニット記録装置の様々なコンポーネントの電気的接続はパネル上に表示され、それらの間の接続は配線によって決定され、実際の接続はパネルが装置に挿入され、所定の位置にロックされたときに行われました。現代のアナログに最も近いのは、フィールドプログラマブルゲートアレイで、一定数のロジック部品が用意されており、その相互接続配線はユーザーが決定します。

ユニットレコードのコントロールパネルを配線するには、機械のコンポーネントとそのタイミングの制約についての知識が必要でした。ほとんどのユニットレコードマシンのコンポーネントは、回転シャフトに同期していました。1つの回転は1つの機械サイクルを表し、その間にパンチングされたカードが1つのステーションから次のステーションに進み、ラインが印刷され、合計が印刷されることがありました。このサイクルは、パンチされたカードの行がリードステーションまたはパンチステーションの下に表示されるタイミングに応じてポイントに分割されていた。ほとんどのマシンでは、カードは表向きで、9エッジ（下端）が最初に投入された。したがって、カードサイクルの最初のポイントは9回、2回目は8回、そして0回となる。9から0までの時間は数字として知られています。これらは、11時、12時と続き、ゾーンとしても知られています。

読み取りステーションでは、一組のスプリング・ワイヤー・ブラシ８０がカードに押し付けられ、各列に１つずつ押し付けられていた（ブラシなしで構成された読み取りステーション４０７は、カードを静止させて保持し、複数回カードを読み取ることができ、その都度、スプリング・ワイヤー・ステーション８０によって生成されるのと同じインパルスを生成する）。ブラシの下を穴が通過すると、ブラシは、電源に接続されたカードの下の導電性表面に接触し、電気パルス（IBM用語ではインパルス）が発生します。各ブラシはコントロールパネルの個別のハブに接続され、必要に応じて別のハブに配線することができました。ワイヤー上のインパルスによって引き起こされる動作は、それがサイクルの中でいつ発生したかによって決まります。したがって、コラム26のパンチマグネットに接続されたワイヤ上で7時間の間に発生したインパルスは、コラム26の7列目に穴を開けることになります。4時に発生した同じワイヤー上のインパルスは、26列の4列目に穴を開けることになります。このようにして計時されたインパルスは、カードにパンチされた穴をブラシの下を通過する際に検出するリードブラシから発生することが多かったが、このようなパルスは、カウンタ出力などの他の回路からも発生する。ゾーンインパルスとデジットインパルスの両方が英数字印刷に必要でした。これらは両方とも単線で送信され、1サイクル内の時間に基づいてリレー回路によって分離されました。

各マシンタイプのコントロールパネルは、論理的に配置された出口（出力）と入口（入力）のハブを提示しました。多くの場所では、2つ以上の隣接する共通のハブが接続されており、その出口または入口に複数のワイヤを接続することができます。ハブのいくつかのグループは一緒に配線されていましたが、内部回路には接続されていませんでした。これらのバスハブは、必要に応じて複数のワイヤを接続するために使用することができました。ワイヤースプリットと呼ばれる小さなコネクタブロックも、コントロールパネルの上にある3本または4本のワイヤを一緒に接続するために利用可能でした。IBM 402 パネルの写真には、いくつかのものが写っています。

#### Field-programmable gate array

[Field-programmable_gate_array(en.wikipedia)](https://en.wikipedia.org/wiki/Field-programmable_gate_array)

FPGA (Field-Programmable Gate Array) は、製造後に顧客または設計者がコンフィギュレーションを行うように設計された集積回路であり、「フィールドプログラマブル」と呼ばれています。FPGA のコンフィギュレーションは、一般的に、特定用途向け集積回路 (ASIC) に使用されるのと同様のハードウェア記述言語 (HDL) を使用して指定されます。以前は回路図を使用してコンフィギュレーショ ンを指定していましたが、電子設計の自動化ツールの出現により、このような指定は珍しくなってきています。

FPGA には、プログラマブル ロジック ブロックの配列と、異なる構成で相互に配線可能な多数のロジック ゲートのように、ブロックを「一緒に配線」できるようにする「再構成可能なインターコネクト」の階層が含まれています。ロジックブロック は、 複雑な組み合わせ機能を実行す る よ う に構成することもで き ますが、AND や XORのような単純なロジックゲートを実行するこ と も で き ます。多くのFPGA では、 ロ ジ ッ ク ブ ロ ッ ク には メ モ リ エレ メ ン ト が含まれてお り 、 単純な フ リ ッ プ フ ロ ッ プ で あ る こ と も あ る し 、 ま た は よ り 完全な メ モ リ ブ ロ ッ ク であ る こ と も あります。FPGAは、次のような機能のために、組み込みシステムの開発で注目すべき役割を果たしています。

ハードウェア(HW)と同時にシステムソフトウェア(SW)の開発を開始する
開発の非常に早い段階でのシステム性能シミュレーションを可能にします。
システムアーキテクチャの最終的なフリーズの前に、様々なシステムパーティショニング（SWとHW）の試行と反復を可能にします。



# アーキテクチャ一覧

## ppc64
[Ppc64(en.wikipedia)](https://en.wikipedia.org/wiki/Ppc64)

ppc64は、Linux、GNU Compiler Collection (GCC)、およびLLVMオープンソースソフトウェアコミュニティで一般的に使用されている識別子であり、64ビットのビッグエンディアンPowerPCおよびPower ISAプロセッサ用に最適化されたアプリケーションのターゲットアーキテクチャを参照するために使用されています。

ppc64leは、OpenPOWER Foundationが提供する技術をプライムターゲットとしてPOWER8で導入された純粋なリトルエンディアンモードであり、x86 Linuxベースのソフトウェアを最小限の労力で移植できることを目的としている。

これら2つの識別子は、ソースコードをコンパイルする際に、ターゲットアーキテクチャを識別するために頻繁に使用されます。

#### ABI

http://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi.html

ELFはコンパイルされたアプリケーションプログラムのためのリンクインタフェースを定義しています。ELFは2つの部分で記述されています。最初の部分は一般的なSystem V ABIです。第二部は、プロセッサ固有の補足資料です。

このドキュメントは、64 ビット PowerPC® プロセッサ・システムで ELF を使用するためのプロセッサ固有の補足資料です。

本書は、ライブラリ・インターフェースを定義していないため、完全なSystem V Application Binary Interface Supplementではありません。

64ビットPowerPCアーキテクチャ™では、プロセッサはビッグエンディアンモードとリトルエンディアンモードの2つのモードのいずれかで実行することができます（第3.1.3項参照）。したがって、このABI仕様では、実際にはビッグエンディアンABIとリトルエンディアンABIの2つのバイナリインタフェースを定義しています。ビッグエンディアン・インターフェースの実装上で実行されるプログラムや（一般的に）生成されたデータは、リトルエンディアン・インターフェースの実装には移植できませんし、その逆も同様です。64ビットPowerPC ELF ABIは32ビットPowerPC ELF ABIと同じではなく、単純な拡張でもありません。64ビットPowerPC ELF ABIをサポートするシステムは、32ビットPowerPC ELF ABIをサポートする必要はありませんが、64ビットPowerPC ELF ABIをサポートする必要はありません。

64ビットPowerPC ELF ABIは、64ビットPowerOpen ABIと同じ構造レイアウトと呼び出し規則を使用することを意図しています。

## 386

[Intel_80386(en.wikipedia)](https://en.wikipedia.org/wiki/Intel_80386)

インテルの 80386（i386 または 386 とも呼ばれる）は、1985 年に発表された 32 ビット・マイクロプロセッサである 。 最初のバージョンは 275,000 トランジスタ を搭載しており、当時の多くのワークステーションやハイエンド・パーソナル・コンピュータの CPU として使用されていた。80286アーキテクチャの32ビット拡張のオリジナルの実装として、80386命令セット、プログラミングモデル、およびバイナリエンコーディングは、現在でもすべての32ビットx86プロセッサの共通分母となっており、文脈に応じてi386-アーキテクチャ、x86、またはIA-32と呼ばれています。

32 ビットの 80386 は、初期の PC に広く普及していた 8086 や 80286 などの初期の 16 ビットプロセッサ向けのコードのほとんどを正しく実行できます。(同じ伝統を踏襲して、現代の 64 ビット x86 プロセッサは、1978 年のオリジナルの 16 ビット 8086 までさかのぼって、古い x86 CPU 向けに書かれたほとんどのプログラムを実行することができます)。長年にわたり、同じアーキテクチャの新しい実装が次々と登場し、オリジナルの 80386 の数百倍（8086 の数千倍）の速さになってきた 。 33MHz の 80386 は、約 11.4MIPS で動作すると報告されている。

80386は1985年10月に発売され、1986年6月からチップの大量生産が開始された 。 80386ベースのコンピュータシステムのメインボードは、当初は煩雑で高価だったが、80386が主流になると製造が合理化された。80386を採用した最初のパーソナルコンピュータはCompaq社が設計・製造したが、IBM PC互換デファクトスタンダードの基本コンポーネントがIBM以外の企業によって初めて更新された。

2006年5月、インテルは80386の生産を2007年9月末で終了することを発表した。このようなシステムは、航空宇宙技術や電子楽器などでは、80386や多くの派生製品の1つを使用するのが一般的である。一部の携帯電話では、BlackBerry 950 や Nokia 9000 Communicator などの 80386 プロセッサ（後に完全にスタティック CMOS 化したもの）も使用されていた。Linux は 2012 年 12 月 11 日まで 80386 プロセッサをサポートし続けたが、カーネルがバージョン 3.8 で 386 固有の命令をカットしたときには 、80386 プロセッサはサポートされなかった。



| Launched                                                     | October 1985                                                 |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| Discontinued                                                 | September 28, 2007[[1\]](https://en.wikipedia.org/wiki/Intel_80386#cite_note-1) |
| Common manufacturer(s)                                       | IntelAMDIBM                                                  |
| Performance                                                  |                                                              |
| Max. [CPU](https://en.wikipedia.org/wiki/Central_processing_unit) [clock rate](https://en.wikipedia.org/wiki/Clock_rate) | 12 MHz to 40 MHz                                             |
| Data width                                                   | 32 bits (386SX: 16 bit)                                      |
| Address width                                                | 32 bits (386SX: 24 bits)                                     |
| Architecture and classification                              |                                                              |
| [Min. feature size](https://en.wikipedia.org/wiki/Technology_node) | 1.5µm to 1µm                                                 |
| [Instruction set](https://en.wikipedia.org/wiki/Instruction_set_architecture) | [x86-32](https://en.wikipedia.org/wiki/X86-32)               |
| Physical specifications                                      |                                                              |
| [Transistors](https://en.wikipedia.org/wiki/Transistor_count) | 275,000                                                      |
| [Co-processor](https://en.wikipedia.org/wiki/Co-processor)   | [Intel 80387](https://en.wikipedia.org/wiki/X87#80387)       |
| Package(s)                                                   | 132-pin [PGA](https://en.wikipedia.org/wiki/Pin_grid_array), 132-pin [PQFP](https://en.wikipedia.org/wiki/Plastic_quad_flat_package); SX variant: 88-pin PGA, 100-pin [BQFP](https://en.wikipedia.org/wiki/Bumpered_quad_flat_package) with 0.635mm pitch |
| Socket(s)                                                    | [PGA132](https://en.wikipedia.org/wiki/Pin_Grid_Array)       |
| History                                                      |                                                              |
| Predecessor                                                  | [Intel 80286](https://en.wikipedia.org/wiki/Intel_80286)     |
| Successor                                                    | [Intel 80486](https://en.wikipedia.org/wiki/Intel_80486)     |

### Architecture

このプロセッサは、x86アーキテクチャを大きく進化させたもので、Intel 8008まで延びた長いプロセッサのラインを延長したものだった。80386の前身は、セグメントベースのメモリ管理および保護システムを搭載した16ビットプロセッサであるIntel 80286であった。80386では、3段命令パイプラインが追加され、アーキテクチャが16ビットから32ビットに拡張され、オンチップのメモリ管理ユニットが追加された。このページング変換ユニットにより、仮想メモリを使用するオペレーティングシステムの実装が大幅に容易になった。また、レジスタデバッグのサポートも提供された。

80386には、リアルモード、プロテクトモード、バーチャルモードの3つの動作モードが搭載されている。286でデビューしたプロテクトモードは、386で最大4GBのメモリをアドレス指定できるように拡張された。新しいバーチャル8086モード（VM86）では、一部のプログラムには互換性がないものもあったが、保護された環境で1つ以上のリアルモードのプログラムを実行することが可能になった。

386はすべてのモードでセグメント化されたメモリモデルを使用しているにもかかわらず、保護されたモードではフラットなメモリモデルを使用しているかのように設定できるようになったことは、AMDが2003年にx86-64をリリースするまで、x86プロセッサファミリーにとって最も重要な機能変更であったと言って間違いないだろう。

386にはいくつかの新しい命令が追加された。BSF、BSR、BT、BTS、BTR、BTC、CDQ、CWDE、LFS、LGS、LSS、MOVSX、MOVZX、SETcc、SHLD、SHRD。

汎用プログラム用に2つのセグメント・レジスタ(FSとGS)が追加され、286の1つのマシン・ステータス・ワードが8つのコントロール・レジスタCR0-CR7に拡張されました。デバッグ・レジスタDR0-DR7はハードウェア・ブレークポイント用に追加されました。MOV命令の新しい形式は、それらにアクセスするために使用されます。

80386の開発におけるチーフ・アーキテクトはJohn H. Crawfordである 。彼は80286アーキテクチャと命令セットを32ビットに拡張する責任者であり、その後、80386チップのマイクロプログラム開発を主導した。

80486およびP5 Pentiumプロセッサのラインは、80386設計の末裔である。

### Datatypes

以下のデータ型は直接サポートされているため、1 つ以上の 80386 マシン命令で実装されています。

ビット（ブール値）、ビットフィールド（最大32ビットのグループ）、ビット文字列（長さ4Gビットまで）。
8ビット整数（バイト）、符号付き（範囲-128～127）または符号なし（範囲0～255）。
16ビット整数、符号付き（範囲-32,768...32,767）または符号なし（範囲0...65,535）のいずれか。
32 ビット整数、符号付き (範囲 -231...231-1) または符号なし (範囲 0...232-1)。
64 ビット整数、符号付き (範囲 -263...263-1) または符号なし (範囲 0...264-1)。
オフセット ： メモリ位置を参照する 16 または 32 ビットの変位 （任意のアドレッシングモードを使用）。
ポ イ ン タ ー、16 ビットのセレクタと 16 ビットまたは 32 ビットのオ フ セ ッ ト 。
文字（8 ビット文字コード）。
文字列。8 ビット、16 ビット、または 32 ビットのワードのシーケンス（長さは最大 4Gbit）。
BCD、アンパックされたバイトで表現される10進数（0～9）。
パックされたBCD、1バイトに2つのBCD桁（範囲0～99）。

## x86-64(AMD64)

[X86-64(en.wikipedia)](https://en.wikipedia.org/wiki/X86-64)

x86-64 (x64、x86_64、AMD64、Intel 64 としても知られています) は、x86 命令セットの 64 ビット版です。64ビットモードと互換性モードの2つの新しい動作モードと、新しい4レベルのページングモードが導入されています。64ビットモードと新しいページングモードでは、32ビット版の前身と比べて大容量の仮想メモリと物理メモリをサポートし、プログラムがより大容量のデータをメモリに格納できるようになっています。浮動小数点演算は必須のSSE2ライクな命令でサポートされており、x87/MMXスタイルのレジスタは一般的には使用されません（64ビットモードでも使用可能です）。その代わりに、32個のベクトルレジスタのセットが使用されます(各レジスタには、1つまたは2つの倍精度の数値、または1～4つの単精度の数値、またはさまざまな整数形式を格納できます)。64ビットモードでは、命令は64ビットオペランドと64ビットアドレッシングモードをサポートするように変更されます。互換モードでは、64ビット・オペレーティング・システムがサポートしている場合、16ビットおよび32ビットのユーザー・アプリケーションを64ビット・アプリケーションと変更せずに共存させて実行することができます 、完全なx86 16ビットおよび32ビット命令セットがハードウェアに実装されたままであるため、これらの古い実行可能ファイルは性能の低下をほとんど感じずに実行できます。また、x86-64をサポートするプロセッサは、80286以降のx86プロセッサと同様に、完全な下位互換性を実現するためにリアルモードで電源を入れます。

AMDが作成し、2000年にリリースされたオリジナル仕様は、AMD、Intel、VIAの3社が実装している。OpteronやAthlon 64プロセッサに搭載されたAMDのK8マイクロアーキテクチャが最初に実装された。これは、Intel以外の会社が設計したx86アーキテクチャへの最初の大きな追加だった。Intelは追随を余儀なくされ、AMDの仕様とソフトウェア互換性のある修正NetBurstファミリを発表した。VIA Technologiesは、VIA IsaiahアーキテクチャのVIA Nanoでx86-64を導入した。

x86-64アーキテクチャは、Intel Itaniumアーキテクチャ(旧IA-64)とは一線を画しており、x86アーキテクチャとはネイティブ命令セットレベルでの互換性がない。一方のアーキテクチャ用にコンパイルされたオペレーティングシステムやアプリケーションは、もう一方のアーキテクチャでは実行できません。

### x86 から見た x86-64

[X86#x86-64(en.wikipedia)](https://en.wikipedia.org/wiki/X86#x86-64)

2000 年代になると、32 ビット x86 プロセッサのメモリ・アドレッシングの限界が、ハイパフォーマンス・コンピューティング・クラスターや強力なデスクトップ・ワークステーションでの利用の障害となってきました。老朽化した32ビットx86は、より多くのメモリをアドレス指定できる、より高度な64ビットRISCアーキテクチャと競合していました。インテルとx86エコシステム全体が、x86が64ビット・コンピューティング時代を生き抜くためには、64ビット・メモリ・アドレッシングを必要としていました。しかし、Intelは、64ビット・デスクトップ・コンピュータへの移行をx86アーキテクチャからの移行に利用するという大胆な一歩を踏み出すべき時期だと考えていましたが、この実験は最終的に失敗に終わりました。

2001年、インテルは、IA-64と名付けられた非x86 64ビット・アーキテクチャをItaniumプロセッサに導入しようと試みた。 IA-64はx86と互換性がなかったが、Itaniumプロセッサはx86命令をIA-64に変換するためのエミュレーション機能を提供したが、これはx86プログラムの性能にひどく影響するため、ユーザーにとって実際に役立つことはほとんどなかった。Itaniumプロセッサは下位互換性を破り、x86チップを使い続けることを好むため、市場はItaniumプロセッサを拒絶し、IA-64用に書き換えられたプログラムはほとんどなかった。

AMDは、下位互換性が損なわれないようにするために、64ビットメモリアドレッシングに向けて別の道を歩むことにした。2003年4月、AMDは64ビット汎用レジスタを搭載した初のx86プロセッサ「Opteron」を発表しましたが、これは新しいx86-64拡張機能（AMD64またはx64とも呼ばれる）を使用して4GB以上の仮想メモリをアドレス指定できるようになりました。x86 アーキテクチャへの 64 ビット拡張は、新たに導入されたロングモードでのみ有効になるため、32 ビットおよび 16 ビットのアプリケーションやオペレーティング システムは、性能をわずかに犠牲にすることなく、16 ビットの Intel 8086 の元の命令と完全に互換性を保ったまま、保護されたモードやその他のモードで AMD64 プロセッサを使用し続けることができました(p13-14)。

市場が互換性のないItaniumプロセッサを拒絶し、MicrosoftがAMD64をサポートしているのを見て、Intelはこれに対応せざるを得ず、2004年7月に独自のx86-64プロセッサ、"Prescott" Pentium 4を発表した。

x86-64では、バッファオーバーランによるセキュリティバグからある程度保護するNXビットも導入されました。

AMDがx86の系譜に64ビットで貢献し、その後Intelに受け入れられた結果、64ビットRISCアーキテクチャはx86エコシステムにとって脅威ではなくなり、ワークステーション市場からほとんど姿を消しました。x86-64は強力なスーパーコンピュータ（AMD OpteronやIntel Xeonの化身）で利用されるようになりました。64ビット・コンピューティングへの大きな飛躍と、32ビットおよび16ビット・ソフトウェアとの下位互換性の維持により、x86アーキテクチャは今日では非常に柔軟なプラットフォームとなり、x86チップは小型の低消費電力システム（例えば、Intel QuarkやIntel Atom）から高速なゲーム用デスクトップ・コンピュータ（例えば、Intel Core i7やAMD FX/Ryzen）まで利用され、さらには大規模なスーパーコンピューティング・クラスタを支配しており、スマートフォンやタブレット市場での競合相手としてARMの32ビットおよび64ビットRISCアーキテクチャだけが事実上残されています。



## ARM

[ARM_architecture(en.wikipedia)](https://en.wikipedia.org/wiki/ARM_architecture)

ARMは、以前はAdvanced RISC Machine、当初はAcorn RISC Machineと呼ばれていましたが、様々な環境に合わせて構成されたコンピュータ・プロセッサ用の縮小命令セット・コンピューティング(RISC)アーキテクチャのファミリーです。ARM社は、このアーキテクチャを開発し、他社にライセンス供与しています。他社は、このアーキテクチャのいずれかを実装した製品（メモリ、インターフェース、無線などを組み込んだシステムオンチップ（SoC）やシステムオンモジュール（SoM）を含む）を設計しています。また、この命令セットを実装するコアを設計し、そのコア設計を自社製品に組み込む多くの企業にライセンス供与しています。

RISCアーキテクチャを採用したプロセッサは、複雑な命令セット・コンピューティング（CISC）アーキテクチャ（ほとんどのパーソナル・コンピュータに搭載されているx86プロセッサなど）を採用したプロセッサに比べて、一般的に必要なトランジスタ数が少なく、コスト、消費電力、放熱性が向上します。これらの特性は、スマートフォン、ノートパソコン、タブレットコンピュータなどの軽量で持ち運び可能なバッテリ駆動の機器や、その他の組み込みシステムに適していますが、サーバやデスクトップにもある程度有用な特性があります。また、大量の電力を消費するスーパーコンピュータでは、ARMは電力効率の良いソリューションでもある。

アームホールディングスは定期的にアーキテクチャのアップデートをリリースしています。アーキテクチャのバージョンARMv3からARMv7では、32ビットのアドレス空間（Arm Holdingsが設立される前に製造されたARMv3以前のチップは、Acorn Archimedesで使用されていたように26ビットのアドレス空間）と32ビットの演算をサポートしており、ほとんどのアーキテクチャでは32ビットの固定長命令が使用されています。Thumbバージョンは、コード密度を向上させるために32ビット命令と16ビット命令の両方を提供する可変長命令セットをサポートしています。一部の古いコアではJavaバイトコードのハードウェア実行も可能で、新しいコアではJavaScript用の命令が1つあります。2011年にリリースされたARMv8-Aアーキテクチャでは、新しい32ビット固定長命令セットにより、64ビットアドレス空間と64ビット演算のサポートが追加されました。オートモーティブ・アプリケーション向けのARM Cortex-A65AEもマルチスレッド・プロセッサで、フォールト・トレラント設計のためのデュアル・コア・ロックステップを備えています（最高レベルのオートモーティブ・セーフティ・インテグリティ・レベルDをサポートしています）。Neoverse N1は、「最小8コア」または「単一のコヒーレント・システム内で64コアから128コアのN1コアにスケールする設計」向けに設計されている。

2019年現在、1,300億個以上のARMプロセッサが生産されており、ARMは最も広く使用されている命令セットアーキテクチャ（ISA）であり、最も多く生産されているISAである現在、広く使用されているCortexコア、古い「クラシック」コア、特化したSecurCoreコアの亜種があり、それぞれにオプション機能を含めたり除外したりすることが可能である。



### 概要

[ARMアーキテクチャ(ja.wikipedia.org)](https://ja.wikipedia.org/wiki/ARMアーキテクチャ)

ARMアーキテクチャは消費電力を抑える特徴を持ち、低消費電力を目標に設計される[モバイル機器](https://ja.wikipedia.org/wiki/携帯機器)において支配的となっている。本アーキテクチャの[命令セット](https://ja.wikipedia.org/wiki/命令_(コンピュータ))は「（基本的に）固定長の命令」「簡素な命令セット」という[RISC](https://ja.wikipedia.org/wiki/RISC)風の特徴を有しつつ、「条件実行、定数シフト/ローテート付きオペランド、比較的豊富なアドレッシングモード」といった[CISC](https://ja.wikipedia.org/wiki/CISC)風の特徴を併せ持つのが特徴的だが、これは初期のARMがパソコン向けに設計された際、当時の同程度の性能のチップとしてはかなり少ないゲート数（約25,000トランジスタ）で実装されたチップの多くの部分を常に活用する設計として工夫されたもので、回路の複雑さを増さないという方向性だというように見れば、CISC風の特徴というよりむしろRISC風の特徴とも言える。ともあれ以上のような設計が、初期の世代の実装において、（性能の割に）低消費電力、小さなコア、（RISCとしては）高いコード密度といった優れた特性に結びつき、広く普及する原動力となった。

2005年の時点で、ARMファミリーは[32ビット](https://ja.wikipedia.org/wiki/32ビット)[組込み](https://ja.wikipedia.org/wiki/組み込みシステム)[マイクロプロセッサ](https://ja.wikipedia.org/wiki/マイクロプロセッサ)（乃至、特にマイクロコントローラ）のおよそ75%を占め[[2\]](https://ja.wikipedia.org/wiki/ARMアーキテクチャ#cite_note-2)、全世界で最も使用されている32ビットCPUアーキテクチャである[*[要出典](https://ja.wikipedia.org/wiki/Wikipedia:「要出典」をクリックされた方へ)*]。ARMアーキテクチャに基づくCPUコアは、[PDA](https://ja.wikipedia.org/wiki/携帯情報端末)・[携帯電話](https://ja.wikipedia.org/wiki/携帯電話)・[メディアプレーヤー](https://ja.wikipedia.org/wiki/メディアプレーヤー)・[携帯型ゲーム](https://ja.wikipedia.org/wiki/携帯型ゲーム)・[電卓](https://ja.wikipedia.org/wiki/電卓)などの携帯機器から、[ハードディスク](https://ja.wikipedia.org/wiki/ハードディスク)・[ルータ](https://ja.wikipedia.org/wiki/ルータ)などの[PC](https://ja.wikipedia.org/wiki/パーソナルコンピュータ)周辺機器まで、あらゆる電子機器に使用される。2013年現在、[NEC](https://ja.wikipedia.org/wiki/日本電気)のEMMA MobileはCortex-A9を[[3\]](https://ja.wikipedia.org/wiki/ARMアーキテクチャ#cite_note-3)や[日立](https://ja.wikipedia.org/wiki/日立製作所)系の[SuperH](https://ja.wikipedia.org/wiki/SuperH)系のSH Mobile GシリーズはARMを内蔵するなど、携帯電話では100%近いシェアがある[*[要出典](https://ja.wikipedia.org/wiki/Wikipedia:「要出典」をクリックされた方へ)*]。

携帯機器や電子機器の高性能化に伴いARMコアの出荷数は加速度的に伸びており、2008年1月の時点で100億個以上、2010年9月の時点で200億個以上が出荷されている。ARMアーキテクチャを使用したプロセッサの例としては、[テキサス・インスツルメンツ](https://ja.wikipedia.org/wiki/テキサス・インスツルメンツ)の[OMAP](https://ja.wikipedia.org/wiki/OMAP)シリーズや[マーベル・テクノロジー・グループ](https://ja.wikipedia.org/wiki/マーベル・テクノロジー・グループ)の[XScale](https://ja.wikipedia.org/wiki/XScale)、[NVIDIA](https://ja.wikipedia.org/wiki/NVIDIA)の[Tegra](https://ja.wikipedia.org/wiki/NVIDIA_Tegra)、[クアルコム](https://ja.wikipedia.org/wiki/クアルコム)の[Snapdragon](https://ja.wikipedia.org/wiki/Snapdragon)、[フリースケール](https://ja.wikipedia.org/wiki/フリースケール・セミコンダクタ)のi.MXシリーズ、[ルネサス エレクトロニクス](https://ja.wikipedia.org/wiki/ルネサスエレクトロニクス)のRZファミリ、Synergyなどがある。

既存のARMプロセッサは組み込みとクライアントシステムに特化していたため全て[32ビット](https://ja.wikipedia.org/wiki/32ビット)であるが、顧客からは電力効率に優れるARMアーキテクチャの[サーバ](https://ja.wikipedia.org/wiki/サーバ)への応用を望む声が高まり[*[要出典](https://ja.wikipedia.org/wiki/Wikipedia:「要出典」をクリックされた方へ)*]、ARM社は2011年10月27日、ARMの[64ビット](https://ja.wikipedia.org/wiki/64ビット)拡張であるARMv8アーキテクチャを発表した。

### 命令セット

ARM は RISC プロセッサであり、Thumb 命令ではなく ARM 命令の場合、その命令セットは

- 32ビット固定長命令
- ロード/ストアアーキテクチャ
- 3オペランドのレジスタ間演算
- 多くの命令が1サイクルで実行可能

といった、多くの32ビットRISCプロセッサに共通する特徴が見られる。

ARMプロセッサは、[PC](https://ja.wikipedia.org/wiki/レジスタ_(コンピュータ)#プログラムカウンタ)相対アドレッシングやプレ-/ポスト-インクリメント・アドレッシングモードなど、RISCとみなされる他のアーキテクチャと比べ、豊富な[アドレッシングモード](https://ja.wikipedia.org/wiki/アドレッシングモード)を持っている。

もう一つ留意すべきことは、ARMの命令セットが時間とともに増加しているということである。例えば、初期のARMプロセッサ（ARM7TDMIより以前のもの）は2バイトの値をロードする命令がなかった。

### ARMの例

#### 条件分岐

```assembly
 loop
        CMP    Ri, Rj       ; i と j を比較
        SUBGT  Ri, Ri, Rj   ; もし "GT" ならば i = i - j;  
        SUBLT  Rj, Rj, Ri   ; もし "LT" ならば j = j - i; 
        BNE    loop         ; もし "NE" ならば loop に戻る
```

多くのARMプログラムは通常RISCプロセッサに期待されるようなプログラムよりも密度の高いものになる。このため、命令フェッチに伴うメモリへのアクセス頻度が少なくなり、分岐に伴うストールも回避しやすく、パイプライン処理を効率的に使うことができる。このことが、ARMがARMより複雑なCPUデザインと競合することを可能にした特徴的な一因のひとつである。

#### Thumb

ARMプロセッサは**Thumb**と呼ばれるコード効率の向上を意図した[16ビット](https://ja.wikipedia.org/wiki/16ビット)長の命令モードを持っている([SuperH](https://ja.wikipedia.org/wiki/SuperH)の命令16ビット/データ32ビットに倣い追加された)。条件実行のための4ビットプレディケートが削除されている。メモリポートやバスが32ビットよりも狭い状況において32ビットコードよりも性能が向上する。多くの場合、組み込みアプリケーションでは32ビットのデータパスを持っているのは一部のアドレス範囲のみであり（例: [ゲームボーイアドバンス](https://ja.wikipedia.org/wiki/ゲームボーイアドバンス)）、残りは16ビットかそれよりも狭くなっている。このような状況では、Thumbコードをコンパイルし、CPUに最も負荷のかかる部分だけを32ビット長の命令セットを使用して手作業で最適化するのが、通常は理にかなっている。Thumb命令とARM命令は単一の実行ファイル内で混在が可能であるが、Thumb命令を実行できるモードとARM命令を実行できるモードは独立しており、両者を使うにはその都度プロセッサの状態を切り替える必要がある。状態の切り替えは分岐命令 (BX, BLX) で行うことができるため、通常は関数単位でThumb命令とARM命令を使い分け、関数呼び出しの際に切り替えを行うのが一般的である。

Thumbテクノロジを搭載した最初のプロセッサはARM7TDMIである。ARM9とそれ以降のファミリは、[XScale](https://ja.wikipedia.org/wiki/XScale)も含めて全てThumbテクノロジを搭載している。



## ARM64

[ARMアーキテクチャ(ja.wikipedia.org)](https://ja.wikipedia.org/wiki/ARMアーキテクチャ)

ARMv8-Aから採用。ARMの64ビットモードアーキテクチャAArch64では、汎用レジスタはすべて64ビットとなり、数も16個から31個に増やされる。サーバ用途も意識して[仮想化](https://ja.wikipedia.org/wiki/仮想化)支援命令および[暗号](https://ja.wikipedia.org/wiki/暗号)支援命令が追加され、[SIMD](https://ja.wikipedia.org/wiki/SIMD)拡張命令であるNEONも大幅に強化される。

### 命令セットの特徴

汎用レジスタの増加と64ビット化に伴い、命令セットは完全に再定義されている。コード効率を重視して命令長は32ビットのままで、32ビットARMの特徴であった条件付き実行命令の大半が削除される。これによって一般的なRISC命令セットに近くなったが、依然としてコードサイズを小さくするための工夫が随所に織り込まれている。

AArch64モードにおける命令セットはA64と呼ばれ、以下にA64命令セットの特徴を示す。

- 即値シフト付きオペランド

  これは従来の32ビットARM命令セットにおいて*フレキシブル第2オペランド (Flexible second operand)* と呼ばれていたものに相当する。多くの基本的な演算命令においては、入力オペランドのうち1つに対する操作を即値左シフト、即値論理右シフト、即値算術右シフト、シフトなし、の4つから選択することができ、演算命令と即値シフト命令を一体化することができる。なお、従来とは異なりローテートは不可能となった。

- 条件付き実行命令

  汎用レジスタ数が倍増したのに伴い、基本命令の多くからは条件付き実行機能が削除されたが、それでも比較的豊富な条件付き実行命令が定義されている。代表的なものを挙げるとCCMP（条件付き比較）、CINC（条件付きインクリメント）、CSEL（条件付き選択; いわゆるCMOV）等が存在する。

- Compare-and-Branch命令

  PC相対分岐においては、ゼロフラグを参照する場合のみであるが比較と条件分岐を1命令で行うことが可能になっている (CBZ/CBNZ)。これは従来Thumb-2命令セットでのみ定義されていたものであるが、A64モードでは基本命令として定義されている。

- 符号拡張/ゼロ拡張付き命令

  算術演算/比較命令については、入力オペランドのうち1つを8,16,32ビットから32もしくは64ビットに符号/ゼロ拡張するバージョンが用意されている。

汎用レジスタは64ビット幅であるが、多くの演算命令にはレジスタの下位32ビットのみを参照する32ビット命令が用意されている。この場合、レジスタの部分書き換えが発生しないように、演算結果の32ビットの値は暗黙のゼロ拡張が行われた上で64ビットレジスタに格納される。

### SIMD and Floating-point (NEON) 命令

A64命令セットにおいては従来のVFPとAdvanced SIMD (NEON) は統合され、一つの命令体系となった。これに伴い、名称については単にSIMD and Floating-point命令と呼ばれるようになった。

主な変更点は倍精度浮動小数点演算への対応、IEEE754への準拠、レジスタ本数の増加の3点である。レジスタについては128ビットのレジスタが32本に増加している。依然として64ビットレジスタとしてアクセスすることも可能であるが、32ビットモードとは異なり、64ビットレジスタは128ビットレジスタの下位64ビットにマッピングされている。

VFPとAdvanced SIMDの統合に伴い、従来はVFPが担っていたスカラの浮動小数点演算命令は、SIMDレジスタのうち下位の32/64ビットにのみ作用する命令として再定義されている。例えば浮動小数点加算命令については

```assembly
 fadd  s2, s1, s0             ; s2 <= s0 + s1（単精度スカラ）
 fadd  d2, d1, d0             ; d2 <= d0 + d1（倍精度スカラ）
 fadd  v2.4s, v1.4s, v0.4s    ; [v2] <= [v0] + [v1]（単精度x4 SIMD）
 fadd  v2.2d, v1.2d, v0.2d    ; [v2] <= [v0] + [v1]（倍精度x2 SIMD）
```

のようなバリエーションが命令のニーモニックを保ちつつ、オペランドのプレフィックス (s, d, v) とサフィックスを変更することによって記述可能になっている（サフィックスについては、一部の環境向けのアセンブラではニーモニック側に付加する省略記法も許されるようである）。これはx86プロセッサのSSE命令セットがスカラ命令とSIMD命令の双方を備えているのとよく似ている。



## wasm

## mips

## mips64

## mips64le

## mipsle

## ppc64

## ppc64le

## riscv64

## s390x
