# このページでまとめたアーキテクチャ一覧

- ppc64
- 386
- amd64
- arm
- arm64
- wasm
- mips
- mips64
- mips64le
- mipsle
- ppc64
- ppc64le
- riscv64
- s390x

# アーキテクチャ

## ppc64
https://en.wikipedia.org/wiki/Ppc64

ppc64は、Linux、GNU Compiler Collection (GCC)、およびLLVMオープンソースソフトウェアコミュニティで一般的に使用されている識別子であり、64ビットのビッグエンディアンPowerPCおよびPower ISAプロセッサ用に最適化されたアプリケーションのターゲットアーキテクチャを参照するために使用されています[1]。

ppc64leは、OpenPOWER Foundationが提供する技術をプライムターゲットとしてPOWER8で導入された純粋なリトルエンディアンモードであり、x86 Linuxベースのソフトウェアを最小限の労力で移植できることを目的としている[2]。

これら2つの識別子は、ソースコードをコンパイルする際に、ターゲットアーキテクチャを識別するために頻繁に使用されます[3]。

#### ABI

http://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi.html

ELFはコンパイルされたアプリケーションプログラムのためのリンクインタフェースを定義しています。ELFは2つの部分で記述されています。最初の部分は一般的なSystem V ABIです。第二部は、プロセッサ固有の補足資料です。

このドキュメントは、64 ビット PowerPC® プロセッサ・システムで ELF を使用するためのプロセッサ固有の補足資料です。

本書は、ライブラリ・インターフェースを定義していないため、完全なSystem V Application Binary Interface Supplementではありません。

64ビットPowerPCアーキテクチャ™では、プロセッサはビッグエンディアンモードとリトルエンディアンモードの2つのモードのいずれかで実行することができます（第3.1.3項参照）。したがって、このABI仕様では、実際にはビッグエンディアンABIとリトルエンディアンABIの2つのバイナリインタフェースを定義しています。ビッグエンディアン・インターフェースの実装上で実行されるプログラムや（一般的に）生成されたデータは、リトルエンディアン・インターフェースの実装には移植できませんし、その逆も同様です。64ビットPowerPC ELF ABIは32ビットPowerPC ELF ABIと同じではなく、単純な拡張でもありません。64ビットPowerPC ELF ABIをサポートするシステムは、32ビットPowerPC ELF ABIをサポートする必要はありませんが、64ビットPowerPC ELF ABIをサポートする必要はありません。

64ビットPowerPC ELF ABIは、64ビットPowerOpen ABIと同じ構造レイアウトと呼び出し規則を使用することを意図しています。

## 386

https://en.wikipedia.org/wiki/Intel_80386

インテルの 80386（i386 または 386 とも呼ばれる）は、1985 年に発表された 32 ビット・マイクロプロセッサである[2] 。 最初のバージョンは 275,000 トランジスタ[3] を搭載しており、当時の多くのワークステーションやハイエンド・パーソナル・コンピュータの CPU として使用されていた。80286アーキテクチャの32ビット拡張のオリジナルの実装として[4]、80386命令セット、プログラミングモデル、およびバイナリエンコーディングは、現在でもすべての32ビットx86プロセッサの共通分母となっており、文脈に応じてi386-アーキテクチャ、x86、またはIA-32と呼ばれています。

32 ビットの 80386 は、初期の PC に広く普及していた 8086 や 80286 などの初期の 16 ビットプロセッサ向けのコードのほとんどを正しく実行できます。(同じ伝統を踏襲して、現代の 64 ビット x86 プロセッサは、1978 年のオリジナルの 16 ビット 8086 までさかのぼって、古い x86 CPU 向けに書かれたほとんどのプログラムを実行することができます)。長年にわたり、同じアーキテクチャの新しい実装が次々と登場し、オリジナルの 80386 の数百倍（8086 の数千倍）の速さになってきた[5] 。 33MHz の 80386 は、約 11.4MIPS で動作すると報告されている[6]。

80386は1985年10月に発売され、1986年6月からチップの大量生産が開始された[7][8] 。 80386ベースのコンピュータシステムのメインボードは、当初は煩雑で高価だったが、80386が主流になると製造が合理化された。80386を採用した最初のパーソナルコンピュータはCompaq社が設計・製造した[9]が、IBM PC互換デファクトスタンダードの基本コンポーネントがIBM以外の企業によって初めて更新された。

2006年5月、インテルは80386の生産を2007年9月末で終了することを発表した[10]。このようなシステムは、航空宇宙技術や電子楽器などでは、80386や多くの派生製品の1つを使用するのが一般的である。一部の携帯電話では、BlackBerry 950[11] や Nokia 9000 Communicator などの 80386 プロセッサ（後に完全にスタティック CMOS 化したもの）も使用されていた。Linux は 2012 年 12 月 11 日まで 80386 プロセッサをサポートし続けたが、カーネルがバージョン 3.8 で 386 固有の命令をカットしたときには[12] 、80386 プロセッサはサポートされなかった。



| Launched                                                     | October 1985                                                 |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| Discontinued                                                 | September 28, 2007[[1\]](https://en.wikipedia.org/wiki/Intel_80386#cite_note-1) |
| Common manufacturer(s)                                       | IntelAMDIBM                                                  |
| Performance                                                  |                                                              |
| Max. [CPU](https://en.wikipedia.org/wiki/Central_processing_unit) [clock rate](https://en.wikipedia.org/wiki/Clock_rate) | 12 MHz to 40 MHz                                             |
| Data width                                                   | 32 bits (386SX: 16 bit)                                      |
| Address width                                                | 32 bits (386SX: 24 bits)                                     |
| Architecture and classification                              |                                                              |
| [Min. feature size](https://en.wikipedia.org/wiki/Technology_node) | 1.5µm to 1µm                                                 |
| [Instruction set](https://en.wikipedia.org/wiki/Instruction_set_architecture) | [x86-32](https://en.wikipedia.org/wiki/X86-32)               |
| Physical specifications                                      |                                                              |
| [Transistors](https://en.wikipedia.org/wiki/Transistor_count) | 275,000                                                      |
| [Co-processor](https://en.wikipedia.org/wiki/Co-processor)   | [Intel 80387](https://en.wikipedia.org/wiki/X87#80387)       |
| Package(s)                                                   | 132-pin [PGA](https://en.wikipedia.org/wiki/Pin_grid_array), 132-pin [PQFP](https://en.wikipedia.org/wiki/Plastic_quad_flat_package); SX variant: 88-pin PGA, 100-pin [BQFP](https://en.wikipedia.org/wiki/Bumpered_quad_flat_package) with 0.635mm pitch |
| Socket(s)                                                    | [PGA132](https://en.wikipedia.org/wiki/Pin_Grid_Array)       |
| History                                                      |                                                              |
| Predecessor                                                  | [Intel 80286](https://en.wikipedia.org/wiki/Intel_80286)     |
| Successor                                                    | [Intel 80486](https://en.wikipedia.org/wiki/Intel_80486)     |

### Architecture

このプロセッサは、x86アーキテクチャを大きく進化させたもので、Intel 8008まで延びた長いプロセッサのラインを延長したものだった。80386の前身は、セグメントベースのメモリ管理および保護システムを搭載した16ビットプロセッサであるIntel 80286であった。80386では、3段命令パイプラインが追加され、アーキテクチャが16ビットから32ビットに拡張され、オンチップのメモリ管理ユニットが追加された。このページング変換ユニットにより、仮想メモリを使用するオペレーティングシステムの実装が大幅に容易になった。また、レジスタデバッグのサポートも提供された。

80386には、リアルモード、プロテクトモード、バーチャルモードの3つの動作モードが搭載されている。286でデビューしたプロテクトモードは、386で最大4GBのメモリをアドレス指定できるように拡張された。新しいバーチャル8086モード（VM86）では、一部のプログラムには互換性がないものもあったが、保護された環境で1つ以上のリアルモードのプログラムを実行することが可能になった。

386はすべてのモードでセグメント化されたメモリモデルを使用しているにもかかわらず、保護されたモードではフラットなメモリモデルを使用しているかのように設定できるようになったことは、AMDが2003年にx86-64をリリースするまで、x86プロセッサファミリーにとって最も重要な機能変更であったと言って間違いないだろう。

386にはいくつかの新しい命令が追加された。BSF、BSR、BT、BTS、BTR、BTC、CDQ、CWDE、LFS、LGS、LSS、MOVSX、MOVZX、SETcc、SHLD、SHRD。

汎用プログラム用に2つのセグメント・レジスタ(FSとGS)が追加され、286の1つのマシン・ステータス・ワードが8つのコントロール・レジスタCR0-CR7に拡張されました。デバッグ・レジスタDR0-DR7はハードウェア・ブレークポイント用に追加されました。MOV命令の新しい形式は、それらにアクセスするために使用されます。

80386の開発におけるチーフ・アーキテクトはJohn H. Crawfordである[13] 。彼は80286アーキテクチャと命令セットを32ビットに拡張する責任者であり、その後、80386チップのマイクロプログラム開発を主導した。

80486およびP5 Pentiumプロセッサのラインは、80386設計の末裔である。

### Datatypes

以下のデータ型は直接サポートされているため、1 つ以上の 80386 マシン命令で実装されています。

ビット（ブール値）、ビットフィールド（最大32ビットのグループ）、ビット文字列（長さ4Gビットまで）。
8ビット整数（バイト）、符号付き（範囲-128～127）または符号なし（範囲0～255）。
16ビット整数、符号付き（範囲-32,768...32,767）または符号なし（範囲0...65,535）のいずれか。
32 ビット整数、符号付き (範囲 -231...231-1) または符号なし (範囲 0...232-1)。
64 ビット整数、符号付き (範囲 -263...263-1) または符号なし (範囲 0...264-1)。
オフセット ： メモリ位置を参照する 16 または 32 ビットの変位 （任意のアドレッシングモードを使用）。
ポ イ ン タ ー、16 ビットのセレクタと 16 ビットまたは 32 ビットのオ フ セ ッ ト 。
文字（8 ビット文字コード）。
文字列。8 ビット、16 ビット、または 32 ビットのワードのシーケンス（長さは最大 4Gbit）[15]。
BCD、アンパックされたバイトで表現される10進数（0～9）。
パックされたBCD、1バイトに2つのBCD桁（範囲0～99）。

## x86-64(AMD64)

[X86-64(en.wikipedia)](https://en.wikipedia.org/wiki/X86-64)

x86-64 (x64、x86_64、AMD64、Intel 64 としても知られています) は、x86 命令セットの 64 ビット版です。64ビットモードと互換性モードの2つの新しい動作モードと、新しい4レベルのページングモードが導入されています。64ビットモードと新しいページングモードでは、32ビット版の前身と比べて大容量の仮想メモリと物理メモリをサポートし、プログラムがより大容量のデータをメモリに格納できるようになっています。浮動小数点演算は必須のSSE2ライクな命令でサポートされており、x87/MMXスタイルのレジスタは一般的には使用されません（64ビットモードでも使用可能です）。その代わりに、32個のベクトルレジスタのセットが使用されます(各レジスタには、1つまたは2つの倍精度の数値、または1～4つの単精度の数値、またはさまざまな整数形式を格納できます)。64ビットモードでは、命令は64ビットオペランドと64ビットアドレッシングモードをサポートするように変更されます。互換モードでは、64ビット・オペレーティング・システムがサポートしている場合、16ビットおよび32ビットのユーザー・アプリケーションを64ビット・アプリケーションと変更せずに共存させて実行することができます 、完全なx86 16ビットおよび32ビット命令セットがハードウェアに実装されたままであるため、これらの古い実行可能ファイルは性能の低下をほとんど感じずに実行できます。また、x86-64をサポートするプロセッサは、80286以降のx86プロセッサと同様に、完全な下位互換性を実現するためにリアルモードで電源を入れます。

AMDが作成し、2000年にリリースされたオリジナル仕様は、AMD、Intel、VIAの3社が実装している。OpteronやAthlon 64プロセッサに搭載されたAMDのK8マイクロアーキテクチャが最初に実装された。これは、Intel以外の会社が設計したx86アーキテクチャへの最初の大きな追加だった。Intelは追随を余儀なくされ、AMDの仕様とソフトウェア互換性のある修正NetBurstファミリを発表した。VIA Technologiesは、VIA IsaiahアーキテクチャのVIA Nanoでx86-64を導入した。

x86-64アーキテクチャは、Intel Itaniumアーキテクチャ(旧IA-64)とは一線を画しており、x86アーキテクチャとはネイティブ命令セットレベルでの互換性がない。一方のアーキテクチャ用にコンパイルされたオペレーティングシステムやアプリケーションは、もう一方のアーキテクチャでは実行できません。

### x86 から見た x86-64

https://en.wikipedia.org/wiki/X86#x86-64

2000 年代になると、32 ビット x86 プロセッサのメモリ・アドレッシングの限界が、ハイパフォーマンス・コンピューティング・クラスターや強力なデスクトップ・ワークステーションでの利用の障害となってきました。老朽化した32ビットx86は、より多くのメモリをアドレス指定できる、より高度な64ビットRISCアーキテクチャと競合していました。インテルとx86エコシステム全体が、x86が64ビット・コンピューティング時代を生き抜くためには、64ビット・メモリ・アドレッシングを必要としていました。しかし、Intelは、64ビット・デスクトップ・コンピュータへの移行をx86アーキテクチャからの移行に利用するという大胆な一歩を踏み出すべき時期だと考えていましたが、この実験は最終的に失敗に終わりました。

2001年、インテルは、IA-64と名付けられた非x86 64ビット・アーキテクチャをItaniumプロセッサに導入しようと試みた。 IA-64はx86と互換性がなかったが、Itaniumプロセッサはx86命令をIA-64に変換するためのエミュレーション機能を提供したが、これはx86プログラムの性能にひどく影響するため、ユーザーにとって実際に役立つことはほとんどなかった。Itaniumプロセッサは下位互換性を破り、x86チップを使い続けることを好むため、市場はItaniumプロセッサを拒絶し、IA-64用に書き換えられたプログラムはほとんどなかった。

AMDは、下位互換性が損なわれないようにするために、64ビットメモリアドレッシングに向けて別の道を歩むことにした。2003年4月、AMDは64ビット汎用レジスタを搭載した初のx86プロセッサ「Opteron」を発表しましたが、これは新しいx86-64拡張機能（AMD64またはx64とも呼ばれる）を使用して4GB以上の仮想メモリをアドレス指定できるようになりました。x86 アーキテクチャへの 64 ビット拡張は、新たに導入されたロングモードでのみ有効になるため、32 ビットおよび 16 ビットのアプリケーションやオペレーティング システムは、性能をわずかに犠牲にすることなく[31]、16 ビットの Intel 8086 の元の命令と完全に互換性を保ったまま、保護されたモードやその他のモードで AMD64 プロセッサを使用し続けることができました[32](p13-14)。

市場が互換性のないItaniumプロセッサを拒絶し、MicrosoftがAMD64をサポートしているのを見て、Intelはこれに対応せざるを得ず、2004年7月に独自のx86-64プロセッサ、"Prescott" Pentium 4を発表した[33]。

x86-64では、バッファオーバーランによるセキュリティバグからある程度保護するNXビットも導入されました。

AMDがx86の系譜に64ビットで貢献し、その後Intelに受け入れられた結果、64ビットRISCアーキテクチャはx86エコシステムにとって脅威ではなくなり、ワークステーション市場からほとんど姿を消しました。x86-64は強力なスーパーコンピュータ（AMD OpteronやIntel Xeonの化身）で利用されるようになりました。64ビット・コンピューティングへの大きな飛躍と、32ビットおよび16ビット・ソフトウェアとの下位互換性の維持により、x86アーキテクチャは今日では非常に柔軟なプラットフォームとなり、x86チップは小型の低消費電力システム（例えば、Intel QuarkやIntel Atom）から高速なゲーム用デスクトップ・コンピュータ（例えば、Intel Core i7やAMD FX/Ryzen）まで利用され、さらには大規模なスーパーコンピューティング・クラスタを支配しており、スマートフォンやタブレット市場での競合相手としてARMの32ビットおよび64ビットRISCアーキテクチャだけが事実上残されています。



## ARM

https://en.wikipedia.org/wiki/ARM_architecture

ARMは、以前はAdvanced RISC Machine、当初はAcorn RISC Machineと呼ばれていましたが、様々な環境に合わせて構成されたコンピュータ・プロセッサ用の縮小命令セット・コンピューティング(RISC)アーキテクチャのファミリーです。ARM社は、このアーキテクチャを開発し、他社にライセンス供与しています。他社は、このアーキテクチャのいずれかを実装した製品（メモリ、インターフェース、無線などを組み込んだシステムオンチップ（SoC）やシステムオンモジュール（SoM）を含む）を設計しています。また、この命令セットを実装するコアを設計し、そのコア設計を自社製品に組み込む多くの企業にライセンス供与しています。

RISCアーキテクチャを採用したプロセッサは、複雑な命令セット・コンピューティング（CISC）アーキテクチャ（ほとんどのパーソナル・コンピュータに搭載されているx86プロセッサなど）を採用したプロセッサに比べて、一般的に必要なトランジスタ数が少なく、コスト、消費電力、放熱性が向上します。これらの特性は、スマートフォン、ノートパソコン、タブレットコンピュータなどの軽量で持ち運び可能なバッテリ駆動の機器や、その他の組み込みシステム[3][4][5]に適していますが、サーバやデスクトップにもある程度有用な特性があります。また、大量の電力を消費するスーパーコンピュータでは、ARMは電力効率の良いソリューションでもある[6]。

アームホールディングスは定期的にアーキテクチャのアップデートをリリースしています。アーキテクチャのバージョンARMv3からARMv7では、32ビットのアドレス空間（Arm Holdingsが設立される前に製造されたARMv3以前のチップは、Acorn Archimedesで使用されていたように26ビットのアドレス空間）と32ビットの演算をサポートしており、ほとんどのアーキテクチャでは32ビットの固定長命令が使用されています。Thumbバージョンは、コード密度を向上させるために32ビット命令と16ビット命令の両方を提供する可変長命令セットをサポートしています。一部の古いコアではJavaバイトコードのハードウェア実行も可能で、新しいコアではJavaScript用の命令が1つあります。2011年にリリースされたARMv8-Aアーキテクチャでは、新しい32ビット固定長命令セットにより、64ビットアドレス空間と64ビット演算のサポートが追加されました[7]。オートモーティブ・アプリケーション向けのARM Cortex-A65AEもマルチスレッド・プロセッサで、フォールト・トレラント設計のためのデュアル・コア・ロックステップを備えています（最高レベルのオートモーティブ・セーフティ・インテグリティ・レベルDをサポートしています）。Neoverse N1は、「最小8コア」または「単一のコヒーレント・システム内で64コアから128コアのN1コアにスケールする設計」向けに設計されている[8]。

2019年現在、1,300億個以上のARMプロセッサが生産されており[9][10][11][12]、ARMは最も広く使用されている命令セットアーキテクチャ（ISA）であり、最も多く生産されているISAである[13][4][14][15][16]現在、広く使用されているCortexコア、古い「クラシック」コア、特化したSecurCoreコアの亜種があり、それぞれにオプション機能を含めたり除外したりすることが可能である。

## arm64



## wasm

## mips

## mips64

## mips64le

## mipsle

## ppc64

## ppc64le

## riscv64

## s390x
